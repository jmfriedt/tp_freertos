
output/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 80 00 20 c1 10 00 08 bd 10 00 08 bb 10 00 08     ... ............
 8000010:	bb 10 00 08 bb 10 00 08 bb 10 00 08 00 00 00 00     ................
	...
 800002c:	71 02 00 08 bd 10 00 08 00 00 00 00 75 02 00 08     q...........u...
 800003c:	79 02 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     y...............
 800004c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800005c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800006c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800007c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800008c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800009c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 80000ac:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 80000bc:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 80000cc:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 80000dc:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 80000ec:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 80000fc:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800010c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800011c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800012c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800013c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800014c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800015c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800016c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800017c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800018c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................
 800019c:	bb 10 00 08 bb 10 00 08 bb 10 00 08 bb 10 00 08     ................

080001ac <vLedsFloat>:
	while(1);
    return 0;
}

void vLedsFloat(void* dummy)
{while(1){
 80001ac:	b508      	push	{r3, lr}
  Led_Hi1();
 80001ae:	f000 f8e7 	bl	8000380 <Led_Hi1>
  vTaskDelay(120/portTICK_RATE_MS);
 80001b2:	2078      	movs	r0, #120	; 0x78
 80001b4:	f000 fd0e 	bl	8000bd4 <vTaskDelay>
  Led_Lo1();
 80001b8:	f000 f8ea 	bl	8000390 <Led_Lo1>
  vTaskDelay(120/portTICK_RATE_MS);
 80001bc:	2078      	movs	r0, #120	; 0x78
 80001be:	f000 fd09 	bl	8000bd4 <vTaskDelay>
 80001c2:	e7f4      	b.n	80001ae <vLedsFloat+0x2>

080001c4 <vLedsFlash>:
 }
}

void vLedsFlash(void* dummy)
{while(1){
 80001c4:	b508      	push	{r3, lr}
  Led_Hi2();
 80001c6:	f000 f8eb 	bl	80003a0 <Led_Hi2>
  vTaskDelay(301/portTICK_RATE_MS);
 80001ca:	f240 102d 	movw	r0, #301	; 0x12d
 80001ce:	f000 fd01 	bl	8000bd4 <vTaskDelay>
  Led_Lo2();
 80001d2:	f000 f8ed 	bl	80003b0 <Led_Lo2>
  vTaskDelay(301/portTICK_RATE_MS);
 80001d6:	f240 102d 	movw	r0, #301	; 0x12d
 80001da:	f000 fcfb 	bl	8000bd4 <vTaskDelay>
 80001de:	e7f2      	b.n	80001c6 <vLedsFlash+0x2>

080001e0 <vPrintUart>:
 }
}

/* Writes each 500 ms */
void vPrintUart(void* dummy)
{portTickType last_wakeup_time;
 80001e0:	b507      	push	{r0, r1, r2, lr}
 last_wakeup_time = xTaskGetTickCount();
 80001e2:	f000 fbd3 	bl	800098c <xTaskGetTickCount>
 80001e6:	ac02      	add	r4, sp, #8
 while(1){uart_puts("Hello World\r\n");
 80001e8:	4d05      	ldr	r5, [pc, #20]	; (8000200 <vPrintUart+0x20>)
}

/* Writes each 500 ms */
void vPrintUart(void* dummy)
{portTickType last_wakeup_time;
 last_wakeup_time = xTaskGetTickCount();
 80001ea:	f844 0d04 	str.w	r0, [r4, #-4]!
 while(1){uart_puts("Hello World\r\n");
 80001ee:	4628      	mov	r0, r5
 80001f0:	f000 f8ec 	bl	80003cc <uart_puts>
	  vTaskDelayUntil(&last_wakeup_time, 500/portTICK_RATE_MS);
 80001f4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80001f8:	4620      	mov	r0, r4
 80001fa:	f000 fcbf 	bl	8000b7c <vTaskDelayUntil>
 80001fe:	e7f6      	b.n	80001ee <vPrintUart+0xe>
 8000200:	0800122b 	.word	0x0800122b

08000204 <main>:

void vLedsFloat(void* dummy);
void vLedsFlash(void* dummy);
void vPrintUart(void* dummy);

int main(void){
 8000204:	b507      	push	{r0, r1, r2, lr}
 volatile int i;
 Usart1_Init(); // inits clock as well
 Led_Init();
 Led_Hi1();

 if (!(pdPASS == xTaskCreate( vLedsFloat, (signed char*) "LedFloat",128,NULL,10,NULL ))) goto hell;
 8000206:	2400      	movs	r4, #0
 8000208:	250a      	movs	r5, #10
void vLedsFlash(void* dummy);
void vPrintUart(void* dummy);

int main(void){
 volatile int i;
 Usart1_Init(); // inits clock as well
 800020a:	f000 f86f 	bl	80002ec <Usart1_Init>
 Led_Init();
 800020e:	f000 f8ad 	bl	800036c <Led_Init>
 Led_Hi1();
 8000212:	f000 f8b5 	bl	8000380 <Led_Hi1>

 if (!(pdPASS == xTaskCreate( vLedsFloat, (signed char*) "LedFloat",128,NULL,10,NULL ))) goto hell;
 8000216:	9401      	str	r4, [sp, #4]
 8000218:	9500      	str	r5, [sp, #0]
 800021a:	4623      	mov	r3, r4
 800021c:	2280      	movs	r2, #128	; 0x80
 800021e:	490e      	ldr	r1, [pc, #56]	; (8000258 <main+0x54>)
 8000220:	480e      	ldr	r0, [pc, #56]	; (800025c <main+0x58>)
 8000222:	f000 faa3 	bl	800076c <xTaskCreate>
 8000226:	2801      	cmp	r0, #1
 8000228:	d115      	bne.n	8000256 <main+0x52>
 if (!(pdPASS == xTaskCreate( vLedsFlash, (signed char*) "LedFlash",128,NULL,10,NULL ))) goto hell;
 800022a:	9401      	str	r4, [sp, #4]
 800022c:	9500      	str	r5, [sp, #0]
 800022e:	4623      	mov	r3, r4
 8000230:	2280      	movs	r2, #128	; 0x80
 8000232:	490b      	ldr	r1, [pc, #44]	; (8000260 <main+0x5c>)
 8000234:	480b      	ldr	r0, [pc, #44]	; (8000264 <main+0x60>)
 8000236:	f000 fa99 	bl	800076c <xTaskCreate>
 800023a:	2801      	cmp	r0, #1
 800023c:	d10b      	bne.n	8000256 <main+0x52>
 if (!(pdPASS == xTaskCreate( vPrintUart, (signed char*) "Uart",    128,NULL,10,NULL ))) goto hell;
 800023e:	9401      	str	r4, [sp, #4]
 8000240:	9500      	str	r5, [sp, #0]
 8000242:	4623      	mov	r3, r4
 8000244:	2280      	movs	r2, #128	; 0x80
 8000246:	4908      	ldr	r1, [pc, #32]	; (8000268 <main+0x64>)
 8000248:	4808      	ldr	r0, [pc, #32]	; (800026c <main+0x68>)
 800024a:	f000 fa8f 	bl	800076c <xTaskCreate>
 800024e:	2801      	cmp	r0, #1
 8000250:	d101      	bne.n	8000256 <main+0x52>

 vTaskStartScheduler();
 8000252:	f000 fb63 	bl	800091c <vTaskStartScheduler>
 8000256:	e7fe      	b.n	8000256 <main+0x52>
 8000258:	08001214 	.word	0x08001214
 800025c:	080001ad 	.word	0x080001ad
 8000260:	0800121d 	.word	0x0800121d
 8000264:	080001c5 	.word	0x080001c5
 8000268:	08001226 	.word	0x08001226
 800026c:	080001e1 	.word	0x080001e1

08000270 <sv_call_handler>:
//
//The only significant change to make is to redirect the sv, pendsv and systick libopencm3 interrupt handlers to those used by FreeRTOS:

void sv_call_handler(void)
{
      vPortSVCHandler();
 8000270:	f000 b96e 	b.w	8000550 <vPortSVCHandler>

08000274 <pend_sv_handler>:
}
 void pend_sv_handler(void)
{
      xPortPendSVHandler();
 8000274:	f000 b99c 	b.w	80005b0 <xPortPendSVHandler>

08000278 <sys_tick_handler>:
}
void sys_tick_handler(void)
{
      xPortSysTickHandler();
 8000278:	f000 b9cc 	b.w	8000614 <xPortSysTickHandler>

0800027c <clock_setup>:
int _write(int file, char *ptr, int len);
#endif


void clock_setup(void)
{
 800027c:	b500      	push	{lr}
 800027e:	b089      	sub	sp, #36	; 0x24
#endif
#else

// APB2 max=84 MHz but when the APB prescaler is NOT 1, the interface clock is fed
// twice the frequency => Sysclk = 140 MHz, APB2=2 but Timers are driven at twice that is 140.
const struct rcc_clock_scale rcc_hse_20mhz_3v3 = {
 8000280:	221c      	movs	r2, #28
 8000282:	2100      	movs	r1, #0
 8000284:	a801      	add	r0, sp, #4
 8000286:	f000 ff77 	bl	8001178 <memset>
 800028a:	2314      	movs	r3, #20
 800028c:	f88d 3004 	strb.w	r3, [sp, #4]
 8000290:	f44f 738c 	mov.w	r3, #280	; 0x118
 8000294:	f8ad 3006 	strh.w	r3, [sp, #6]
 8000298:	2302      	movs	r3, #2
 800029a:	f88d 3008 	strb.w	r3, [sp, #8]
 800029e:	2306      	movs	r3, #6
 80002a0:	f88d 3009 	strb.w	r3, [sp, #9]
 80002a4:	f240 6304 	movw	r3, #1540	; 0x604
 80002a8:	9303      	str	r3, [sp, #12]
 80002aa:	2305      	movs	r3, #5
 80002ac:	f88d 3011 	strb.w	r3, [sp, #17]
 80002b0:	2304      	movs	r3, #4
 80002b2:	f88d 3012 	strb.w	r3, [sp, #18]
 80002b6:	4b0a      	ldr	r3, [pc, #40]	; (80002e0 <clock_setup+0x64>)
 80002b8:	9305      	str	r3, [sp, #20]
 80002ba:	4b0a      	ldr	r3, [pc, #40]	; (80002e4 <clock_setup+0x68>)
 80002bc:	9306      	str	r3, [sp, #24]
  *        Flash Latency(WS)                      | 4
  *        Require 48MHz for USB OTG FS,          | Disabled
  *        SDIO and RNG clock                     |
*/

 rcc_clock_setup_hse_3v3(&rcc_hse_20mhz_3v3); // custom version
 80002be:	a801      	add	r0, sp, #4
#endif
#else

// APB2 max=84 MHz but when the APB prescaler is NOT 1, the interface clock is fed
// twice the frequency => Sysclk = 140 MHz, APB2=2 but Timers are driven at twice that is 140.
const struct rcc_clock_scale rcc_hse_20mhz_3v3 = {
 80002c0:	4b09      	ldr	r3, [pc, #36]	; (80002e8 <clock_setup+0x6c>)
 80002c2:	9307      	str	r3, [sp, #28]
  *        Flash Latency(WS)                      | 4
  *        Require 48MHz for USB OTG FS,          | Disabled
  *        SDIO and RNG clock                     |
*/

 rcc_clock_setup_hse_3v3(&rcc_hse_20mhz_3v3); // custom version
 80002c4:	f000 fde6 	bl	8000e94 <rcc_clock_setup_hse_3v3>

#endif
  rcc_periph_clock_enable(RCC_GPIOA); // Enable GPIOA clock
 80002c8:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 80002cc:	f000 fee8 	bl	80010a0 <rcc_periph_clock_enable>
  rcc_periph_clock_enable(RCC_USART1);
 80002d0:	f640 0084 	movw	r0, #2180	; 0x884
 80002d4:	f000 fee4 	bl	80010a0 <rcc_periph_clock_enable>
}
 80002d8:	b009      	add	sp, #36	; 0x24
 80002da:	f85d fb04 	ldr.w	pc, [sp], #4
 80002de:	bf00      	nop
 80002e0:	08583b00 	.word	0x08583b00
 80002e4:	02160ec0 	.word	0x02160ec0
 80002e8:	042c1d80 	.word	0x042c1d80

080002ec <Usart1_Init>:


void Usart1_Init(void)
{ // Setup GPIO pin GPIO_USART1_TX/GPIO9 on GPIO port A for transmit. */
 80002ec:	b510      	push	{r4, lr}
  clock_setup();
#ifdef STM32F1
  gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
#else
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9);  //GPA9 : Tx send from STM32 to ext
 80002ee:	4c1e      	ldr	r4, [pc, #120]	; (8000368 <Usart1_Init+0x7c>)
}


void Usart1_Init(void)
{ // Setup GPIO pin GPIO_USART1_TX/GPIO9 on GPIO port A for transmit. */
  clock_setup();
 80002f0:	f7ff ffc4 	bl	800027c <clock_setup>
#ifdef STM32F1
  gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
#else
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9);  //GPA9 : Tx send from STM32 to ext
 80002f4:	4620      	mov	r0, r4
 80002f6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80002fa:	2200      	movs	r2, #0
 80002fc:	2102      	movs	r1, #2
 80002fe:	f000 fe24 	bl	8000f4a <gpio_mode_setup>
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO10); //GPD10: Rx recieve from ext to STM32
 8000302:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000306:	4620      	mov	r0, r4
 8000308:	2200      	movs	r2, #0
 800030a:	2102      	movs	r1, #2
 800030c:	f000 fe1d 	bl	8000f4a <gpio_mode_setup>
  gpio_set_af (GPIOA, GPIO_AF7, GPIO9);
 8000310:	4620      	mov	r0, r4
 8000312:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000316:	2107      	movs	r1, #7
 8000318:	f000 fe39 	bl	8000f8e <gpio_set_af>
  gpio_set_af (GPIOA, GPIO_AF7, GPIO10);
 800031c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000320:	4620      	mov	r0, r4
 8000322:	2107      	movs	r1, #7
#endif
  usart_set_baudrate(USART1, 115200);
 8000324:	f5a4 4470 	sub.w	r4, r4, #61440	; 0xf000
      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
#else
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9);  //GPA9 : Tx send from STM32 to ext
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO10); //GPD10: Rx recieve from ext to STM32
  gpio_set_af (GPIOA, GPIO_AF7, GPIO9);
  gpio_set_af (GPIOA, GPIO_AF7, GPIO10);
 8000328:	f000 fe31 	bl	8000f8e <gpio_set_af>
#endif
  usart_set_baudrate(USART1, 115200);
 800032c:	4620      	mov	r0, r4
 800032e:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8000332:	f000 fe59 	bl	8000fe8 <usart_set_baudrate>
  usart_set_databits(USART1, 8);
 8000336:	4620      	mov	r0, r4
 8000338:	2108      	movs	r1, #8
 800033a:	f000 fe6d 	bl	8001018 <usart_set_databits>
  usart_set_stopbits(USART1, USART_STOPBITS_1);
 800033e:	4620      	mov	r0, r4
 8000340:	2100      	movs	r1, #0
 8000342:	f000 fe72 	bl	800102a <usart_set_stopbits>
  usart_set_mode(USART1, USART_MODE_TX);
 8000346:	4620      	mov	r0, r4
 8000348:	2108      	movs	r1, #8
 800034a:	f000 fe7a 	bl	8001042 <usart_set_mode>
  usart_set_parity(USART1, USART_PARITY_NONE);
 800034e:	4620      	mov	r0, r4
 8000350:	2100      	movs	r1, #0
 8000352:	f000 fe70 	bl	8001036 <usart_set_parity>
  usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);
 8000356:	4620      	mov	r0, r4
 8000358:	2100      	movs	r1, #0
 800035a:	f000 fe78 	bl	800104e <usart_set_flow_control>

  usart_enable(USART1);  // PA9 & PA10 for USART1
 800035e:	4620      	mov	r0, r4
}
 8000360:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usart_set_stopbits(USART1, USART_STOPBITS_1);
  usart_set_mode(USART1, USART_MODE_TX);
  usart_set_parity(USART1, USART_PARITY_NONE);
  usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);

  usart_enable(USART1);  // PA9 & PA10 for USART1
 8000364:	f000 be79 	b.w	800105a <usart_enable>
 8000368:	40020000 	.word	0x40020000

0800036c <Led_Init>:
void Led_Init(void)
{
#ifdef STM32F1
 gpio_set_mode(GPIOC,GPIO_MODE_OUTPUT_2_MHZ,GPIO_CNF_OUTPUT_PUSHPULL,GPIO8|GPIO9|GPIO1|GPIO2);
#else
 gpio_mode_setup(GPIOA, GPIO_MODE_OUTPUT,GPIO_PUPD_NONE, GPIO12|GPIO13); 
 800036c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8000370:	2200      	movs	r2, #0
 8000372:	2101      	movs	r1, #1
 8000374:	4801      	ldr	r0, [pc, #4]	; (800037c <Led_Init+0x10>)
 8000376:	f000 bde8 	b.w	8000f4a <gpio_mode_setup>
 800037a:	bf00      	nop
 800037c:	40020000 	.word	0x40020000

08000380 <Led_Hi1>:
void Led_Hi1(void) {gpio_set  (GPIOC, GPIO9);gpio_set  (GPIOC, GPIO2);}
void Led_Lo1(void) {gpio_clear(GPIOC, GPIO9);gpio_clear(GPIOC, GPIO2);}
void Led_Hi2(void) {gpio_set  (GPIOC, GPIO8);gpio_set  (GPIOC, GPIO1);}
void Led_Lo2(void) {gpio_clear(GPIOC, GPIO8);gpio_clear(GPIOC, GPIO1);}
#else
void Led_Hi1(void) {gpio_set  (GPIOA, GPIO12);}
 8000380:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000384:	4801      	ldr	r0, [pc, #4]	; (800038c <Led_Hi1+0xc>)
 8000386:	f000 bddb 	b.w	8000f40 <gpio_set>
 800038a:	bf00      	nop
 800038c:	40020000 	.word	0x40020000

08000390 <Led_Lo1>:
void Led_Lo1(void) {gpio_clear(GPIOA, GPIO12);}
 8000390:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000394:	4801      	ldr	r0, [pc, #4]	; (800039c <Led_Lo1+0xc>)
 8000396:	f000 bdd5 	b.w	8000f44 <gpio_clear>
 800039a:	bf00      	nop
 800039c:	40020000 	.word	0x40020000

080003a0 <Led_Hi2>:
void Led_Hi2(void) {gpio_set  (GPIOA, GPIO13);}
 80003a0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80003a4:	4801      	ldr	r0, [pc, #4]	; (80003ac <Led_Hi2+0xc>)
 80003a6:	f000 bdcb 	b.w	8000f40 <gpio_set>
 80003aa:	bf00      	nop
 80003ac:	40020000 	.word	0x40020000

080003b0 <Led_Lo2>:
void Led_Lo2(void) {gpio_clear(GPIOA, GPIO13);}
 80003b0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80003b4:	4801      	ldr	r0, [pc, #4]	; (80003bc <Led_Lo2+0xc>)
 80003b6:	f000 bdc5 	b.w	8000f44 <gpio_clear>
 80003ba:	bf00      	nop
 80003bc:	40020000 	.word	0x40020000

080003c0 <uart_putc>:
  errno = EIO;
  return -1;
}
#endif

void uart_putc(char c) {usart_send_blocking(USART1, c);} // USART1: send byte
 80003c0:	4601      	mov	r1, r0
 80003c2:	4801      	ldr	r0, [pc, #4]	; (80003c8 <uart_putc+0x8>)
 80003c4:	f000 be4e 	b.w	8001064 <usart_send_blocking>
 80003c8:	40011000 	.word	0x40011000

080003cc <uart_puts>:

/* Writes a zero teminated string over the serial line*/
void uart_puts(char *c) {while(*c!=0) uart_putc(*(c++));}
 80003cc:	b510      	push	{r4, lr}
 80003ce:	1e44      	subs	r4, r0, #1
 80003d0:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80003d4:	b900      	cbnz	r0, 80003d8 <uart_puts+0xc>
 80003d6:	bd10      	pop	{r4, pc}
 80003d8:	f7ff fff2 	bl	80003c0 <uart_putc>
 80003dc:	e7f8      	b.n	80003d0 <uart_puts+0x4>
	...

080003e0 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 80003e0:	b570      	push	{r4, r5, r6, lr}
 80003e2:	4604      	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 80003e4:	f000 faca 	bl	800097c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 80003e8:	4825      	ldr	r0, [pc, #148]	; (8000480 <pvPortMalloc+0xa0>)
 80003ea:	6801      	ldr	r1, [r0, #0]
 80003ec:	b971      	cbnz	r1, 800040c <pvPortMalloc+0x2c>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 80003ee:	4b25      	ldr	r3, [pc, #148]	; (8000484 <pvPortMalloc+0xa4>)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80003f0:	4a25      	ldr	r2, [pc, #148]	; (8000488 <pvPortMalloc+0xa8>)
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 80003f2:	f023 0307 	bic.w	r3, r3, #7

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80003f6:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80003f8:	6051      	str	r1, [r2, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 80003fa:	4a24      	ldr	r2, [pc, #144]	; (800048c <pvPortMalloc+0xac>)
 80003fc:	f241 35f8 	movw	r5, #5112	; 0x13f8
	xEnd.pxNextFreeBlock = NULL;
 8000400:	e882 0022 	stmia.w	r2, {r1, r5}

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 8000404:	e883 0024 	stmia.w	r3, {r2, r5}
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 8000408:	2301      	movs	r3, #1
 800040a:	6003      	str	r3, [r0, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 800040c:	b12c      	cbz	r4, 800041a <pvPortMalloc+0x3a>
		{
			xWantedSize += heapSTRUCT_SIZE;
 800040e:	3408      	adds	r4, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 8000410:	0763      	lsls	r3, r4, #29
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8000412:	bf1c      	itt	ne
 8000414:	f024 0407 	bicne.w	r4, r4, #7
 8000418:	3408      	addne	r4, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 800041a:	1e62      	subs	r2, r4, #1
 800041c:	f241 33f6 	movw	r3, #5110	; 0x13f6
 8000420:	429a      	cmp	r2, r3
 8000422:	d807      	bhi.n	8000434 <pvPortMalloc+0x54>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 8000424:	4a18      	ldr	r2, [pc, #96]	; (8000488 <pvPortMalloc+0xa8>)
 8000426:	6813      	ldr	r3, [r2, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8000428:	6859      	ldr	r1, [r3, #4]
 800042a:	428c      	cmp	r4, r1
 800042c:	d804      	bhi.n	8000438 <pvPortMalloc+0x58>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 800042e:	4817      	ldr	r0, [pc, #92]	; (800048c <pvPortMalloc+0xac>)
 8000430:	4283      	cmp	r3, r0
 8000432:	d107      	bne.n	8000444 <pvPortMalloc+0x64>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 8000434:	2500      	movs	r5, #0
 8000436:	e01d      	b.n	8000474 <pvPortMalloc+0x94>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8000438:	6818      	ldr	r0, [r3, #0]
 800043a:	2800      	cmp	r0, #0
 800043c:	d0f7      	beq.n	800042e <pvPortMalloc+0x4e>
 800043e:	461a      	mov	r2, r3
 8000440:	4603      	mov	r3, r0
 8000442:	e7f1      	b.n	8000428 <pvPortMalloc+0x48>
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8000444:	6818      	ldr	r0, [r3, #0]
			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 8000446:	6815      	ldr	r5, [r2, #0]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8000448:	6010      	str	r0, [r2, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800044a:	1b0a      	subs	r2, r1, r4
 800044c:	2a10      	cmp	r2, #16
			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 800044e:	f105 0508 	add.w	r5, r5, #8
				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8000452:	d90a      	bls.n	800046a <pvPortMalloc+0x8a>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8000454:	1919      	adds	r1, r3, r4

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8000456:	604a      	str	r2, [r1, #4]
					pxBlock->xBlockSize = xWantedSize;
 8000458:	605c      	str	r4, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 800045a:	684e      	ldr	r6, [r1, #4]
 800045c:	4a0a      	ldr	r2, [pc, #40]	; (8000488 <pvPortMalloc+0xa8>)
 800045e:	6810      	ldr	r0, [r2, #0]
 8000460:	6844      	ldr	r4, [r0, #4]
 8000462:	42a6      	cmp	r6, r4
 8000464:	d80a      	bhi.n	800047c <pvPortMalloc+0x9c>
 8000466:	6008      	str	r0, [r1, #0]
 8000468:	6011      	str	r1, [r2, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 800046a:	4909      	ldr	r1, [pc, #36]	; (8000490 <pvPortMalloc+0xb0>)
 800046c:	685b      	ldr	r3, [r3, #4]
 800046e:	680a      	ldr	r2, [r1, #0]
 8000470:	1ad2      	subs	r2, r2, r3
 8000472:	600a      	str	r2, [r1, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8000474:	f000 fb16 	bl	8000aa4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8000478:	4628      	mov	r0, r5
 800047a:	bd70      	pop	{r4, r5, r6, pc}
 800047c:	4602      	mov	r2, r0
 800047e:	e7ee      	b.n	800045e <pvPortMalloc+0x7e>
 8000480:	2000141c 	.word	0x2000141c
 8000484:	2000001c 	.word	0x2000001c
 8000488:	20001420 	.word	0x20001420
 800048c:	20001414 	.word	0x20001414
 8000490:	20000000 	.word	0x20000000

08000494 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8000494:	b538      	push	{r3, r4, r5, lr}
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 8000496:	4604      	mov	r4, r0
 8000498:	b1b8      	cbz	r0, 80004ca <vPortFree+0x36>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 800049a:	f1a0 0508 	sub.w	r5, r0, #8

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 800049e:	f000 fa6d 	bl	800097c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80004a2:	f854 0c04 	ldr.w	r0, [r4, #-4]
 80004a6:	4a09      	ldr	r2, [pc, #36]	; (80004cc <vPortFree+0x38>)
 80004a8:	6811      	ldr	r1, [r2, #0]
 80004aa:	684b      	ldr	r3, [r1, #4]
 80004ac:	4298      	cmp	r0, r3
 80004ae:	d80a      	bhi.n	80004c6 <vPortFree+0x32>
 80004b0:	f844 1c08 	str.w	r1, [r4, #-8]
 80004b4:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 80004b6:	4a06      	ldr	r2, [pc, #24]	; (80004d0 <vPortFree+0x3c>)
 80004b8:	6813      	ldr	r3, [r2, #0]
 80004ba:	4403      	add	r3, r0
 80004bc:	6013      	str	r3, [r2, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
 80004be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 80004c2:	f000 baef 	b.w	8000aa4 <xTaskResumeAll>
 80004c6:	460a      	mov	r2, r1
 80004c8:	e7ee      	b.n	80004a8 <vPortFree+0x14>
 80004ca:	bd38      	pop	{r3, r4, r5, pc}
 80004cc:	20001420 	.word	0x20001420
 80004d0:	20000000 	.word	0x20000000

080004d4 <prvTaskExitError>:

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80004d4:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 80004d8:	f383 8811 	msr	BASEPRI, r3
 80004dc:	f3bf 8f6f 	isb	sy
 80004e0:	f3bf 8f4f 	dsb	sy
 80004e4:	e7fe      	b.n	80004e4 <prvTaskExitError+0x10>
	...

080004e8 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 80004e8:	4806      	ldr	r0, [pc, #24]	; (8000504 <prvPortStartFirstTask+0x1c>)
 80004ea:	6800      	ldr	r0, [r0, #0]
 80004ec:	6800      	ldr	r0, [r0, #0]
 80004ee:	f380 8808 	msr	MSP, r0
 80004f2:	b662      	cpsie	i
 80004f4:	b661      	cpsie	f
 80004f6:	f3bf 8f4f 	dsb	sy
 80004fa:	f3bf 8f6f 	isb	sy
 80004fe:	df00      	svc	0
 8000500:	bf00      	nop
 8000502:	0000      	.short	0x0000
 8000504:	e000ed08 	.word	0xe000ed08

08000508 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8000508:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8000518 <vPortEnableVFP+0x10>
 800050c:	6801      	ldr	r1, [r0, #0]
 800050e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000512:	6001      	str	r1, [r0, #0]
 8000514:	4770      	bx	lr
 8000516:	0000      	.short	0x0000
 8000518:	e000ed88 	.word	0xe000ed88

0800051c <pxPortInitialiseStack>:

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800051c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000520:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8000524:	4b07      	ldr	r3, [pc, #28]	; (8000544 <pxPortInitialiseStack+0x28>)
 8000526:	f840 3c0c 	str.w	r3, [r0, #-12]
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800052a:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 800052e:	f06f 0302 	mvn.w	r3, #2
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8000532:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8000536:	f840 2c20 	str.w	r2, [r0, #-32]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 800053a:	f840 3c24 	str.w	r3, [r0, #-36]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 800053e:	3844      	subs	r0, #68	; 0x44
 8000540:	4770      	bx	lr
 8000542:	bf00      	nop
 8000544:	080004d5 	.word	0x080004d5
	...

08000550 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000550:	4b07      	ldr	r3, [pc, #28]	; (8000570 <pxCurrentTCBConst2>)
 8000552:	6819      	ldr	r1, [r3, #0]
 8000554:	6808      	ldr	r0, [r1, #0]
 8000556:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800055a:	f380 8809 	msr	PSP, r0
 800055e:	f3bf 8f6f 	isb	sy
 8000562:	f04f 0000 	mov.w	r0, #0
 8000566:	f380 8811 	msr	BASEPRI, r0
 800056a:	4770      	bx	lr
 800056c:	f3af 8000 	nop.w

08000570 <pxCurrentTCBConst2>:
 8000570:	20001428 	.word	0x20001428

08000574 <vPortEnterCritical>:
 8000574:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8000578:	f383 8811 	msr	BASEPRI, r3
 800057c:	f3bf 8f6f 	isb	sy
 8000580:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8000584:	4a02      	ldr	r2, [pc, #8]	; (8000590 <vPortEnterCritical+0x1c>)
 8000586:	6813      	ldr	r3, [r2, #0]
 8000588:	3301      	adds	r3, #1
 800058a:	6013      	str	r3, [r2, #0]
 800058c:	4770      	bx	lr
 800058e:	bf00      	nop
 8000590:	20000004 	.word	0x20000004

08000594 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
 8000594:	4a03      	ldr	r2, [pc, #12]	; (80005a4 <vPortExitCritical+0x10>)
 8000596:	6813      	ldr	r3, [r2, #0]
 8000598:	3b01      	subs	r3, #1
 800059a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800059c:	b90b      	cbnz	r3, 80005a2 <vPortExitCritical+0xe>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800059e:	f383 8811 	msr	BASEPRI, r3
 80005a2:	4770      	bx	lr
 80005a4:	20000004 	.word	0x20000004
	...

080005b0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80005b0:	f3ef 8009 	mrs	r0, PSP
 80005b4:	f3bf 8f6f 	isb	sy
 80005b8:	4b15      	ldr	r3, [pc, #84]	; (8000610 <pxCurrentTCBConst>)
 80005ba:	681a      	ldr	r2, [r3, #0]
 80005bc:	f01e 0f10 	tst.w	lr, #16
 80005c0:	bf08      	it	eq
 80005c2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80005c6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80005ca:	6010      	str	r0, [r2, #0]
 80005cc:	f84d 3d04 	str.w	r3, [sp, #-4]!
 80005d0:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80005d4:	f380 8811 	msr	BASEPRI, r0
 80005d8:	f3bf 8f4f 	dsb	sy
 80005dc:	f3bf 8f6f 	isb	sy
 80005e0:	f000 fb10 	bl	8000c04 <vTaskSwitchContext>
 80005e4:	f04f 0000 	mov.w	r0, #0
 80005e8:	f380 8811 	msr	BASEPRI, r0
 80005ec:	bc08      	pop	{r3}
 80005ee:	6819      	ldr	r1, [r3, #0]
 80005f0:	6808      	ldr	r0, [r1, #0]
 80005f2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80005f6:	f01e 0f10 	tst.w	lr, #16
 80005fa:	bf08      	it	eq
 80005fc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8000600:	f380 8809 	msr	PSP, r0
 8000604:	f3bf 8f6f 	isb	sy
 8000608:	4770      	bx	lr
 800060a:	bf00      	nop
 800060c:	f3af 8000 	nop.w

08000610 <pxCurrentTCBConst>:
 8000610:	20001428 	.word	0x20001428

08000614 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8000614:	b508      	push	{r3, lr}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8000616:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 800061a:	f383 8811 	msr	BASEPRI, r3
 800061e:	f3bf 8f6f 	isb	sy
 8000622:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8000626:	f000 f9b7 	bl	8000998 <xTaskIncrementTick>
 800062a:	b118      	cbz	r0, 8000634 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800062c:	4b03      	ldr	r3, [pc, #12]	; (800063c <xPortSysTickHandler+0x28>)
 800062e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000632:	601a      	str	r2, [r3, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8000634:	2300      	movs	r3, #0
 8000636:	f383 8811 	msr	BASEPRI, r3
 800063a:	bd08      	pop	{r3, pc}
 800063c:	e000ed04 	.word	0xe000ed04

08000640 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8000640:	4b03      	ldr	r3, [pc, #12]	; (8000650 <vPortSetupTimerInterrupt+0x10>)
 8000642:	4a04      	ldr	r2, [pc, #16]	; (8000654 <vPortSetupTimerInterrupt+0x14>)
 8000644:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8000646:	2207      	movs	r2, #7
 8000648:	f843 2c04 	str.w	r2, [r3, #-4]
 800064c:	4770      	bx	lr
 800064e:	bf00      	nop
 8000650:	e000e014 	.word	0xe000e014
 8000654:	0001193f 	.word	0x0001193f

08000658 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8000658:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800065a:	4b0c      	ldr	r3, [pc, #48]	; (800068c <xPortStartScheduler+0x34>)
 800065c:	681a      	ldr	r2, [r3, #0]
 800065e:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8000662:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8000664:	681a      	ldr	r2, [r3, #0]
 8000666:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 800066a:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800066c:	f7ff ffe8 	bl	8000640 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000670:	4b07      	ldr	r3, [pc, #28]	; (8000690 <xPortStartScheduler+0x38>)
 8000672:	2200      	movs	r2, #0
 8000674:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8000676:	f7ff ff47 	bl	8000508 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800067a:	4a06      	ldr	r2, [pc, #24]	; (8000694 <xPortStartScheduler+0x3c>)
 800067c:	6813      	ldr	r3, [r2, #0]
 800067e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8000682:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8000684:	f7ff ff30 	bl	80004e8 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8000688:	f7ff ff24 	bl	80004d4 <prvTaskExitError>
 800068c:	e000ed20 	.word	0xe000ed20
 8000690:	20000004 	.word	0x20000004
 8000694:	e000ef34 	.word	0xe000ef34

08000698 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8000698:	4906      	ldr	r1, [pc, #24]	; (80006b4 <prvIdleTask+0x1c>)
			{
				taskYIELD();
 800069a:	4b07      	ldr	r3, [pc, #28]	; (80006b8 <prvIdleTask+0x20>)
 800069c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80006a0:	6808      	ldr	r0, [r1, #0]
 80006a2:	2801      	cmp	r0, #1
 80006a4:	d9fd      	bls.n	80006a2 <prvIdleTask+0xa>
			{
				taskYIELD();
 80006a6:	601a      	str	r2, [r3, #0]
 80006a8:	f3bf 8f4f 	dsb	sy
 80006ac:	f3bf 8f6f 	isb	sy
 80006b0:	e7f6      	b.n	80006a0 <prvIdleTask+0x8>
 80006b2:	bf00      	nop
 80006b4:	20001434 	.word	0x20001434
 80006b8:	e000ed04 	.word	0xe000ed04

080006bc <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80006bc:	4a06      	ldr	r2, [pc, #24]	; (80006d8 <prvResetNextTaskUnblockTime+0x1c>)
 80006be:	6813      	ldr	r3, [r2, #0]
 80006c0:	6819      	ldr	r1, [r3, #0]
 80006c2:	4b06      	ldr	r3, [pc, #24]	; (80006dc <prvResetNextTaskUnblockTime+0x20>)
 80006c4:	b919      	cbnz	r1, 80006ce <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80006c6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80006ca:	601a      	str	r2, [r3, #0]
 80006cc:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80006ce:	6812      	ldr	r2, [r2, #0]
 80006d0:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80006d2:	68d2      	ldr	r2, [r2, #12]
 80006d4:	6852      	ldr	r2, [r2, #4]
 80006d6:	e7f8      	b.n	80006ca <prvResetNextTaskUnblockTime+0xe>
 80006d8:	2000142c 	.word	0x2000142c
 80006dc:	200014d8 	.word	0x200014d8

080006e0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80006e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80006e2:	4b1b      	ldr	r3, [pc, #108]	; (8000750 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80006e4:	4e1b      	ldr	r6, [pc, #108]	; (8000754 <prvAddCurrentTaskToDelayedList+0x74>)


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80006e6:	681d      	ldr	r5, [r3, #0]
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80006e8:	4604      	mov	r4, r0
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80006ea:	6830      	ldr	r0, [r6, #0]
 80006ec:	3004      	adds	r0, #4
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80006ee:	460f      	mov	r7, r1
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80006f0:	f000 fae7 	bl	8000cc2 <uxListRemove>
 80006f4:	4633      	mov	r3, r6
 80006f6:	b940      	cbnz	r0, 800070a <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80006f8:	6831      	ldr	r1, [r6, #0]
 80006fa:	4e17      	ldr	r6, [pc, #92]	; (8000758 <prvAddCurrentTaskToDelayedList+0x78>)
 80006fc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80006fe:	6832      	ldr	r2, [r6, #0]
 8000700:	2001      	movs	r0, #1
 8000702:	4088      	lsls	r0, r1
 8000704:	ea22 0200 	bic.w	r2, r2, r0
 8000708:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800070a:	1c62      	adds	r2, r4, #1
 800070c:	d107      	bne.n	800071e <prvAddCurrentTaskToDelayedList+0x3e>
 800070e:	b137      	cbz	r7, 800071e <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000710:	6819      	ldr	r1, [r3, #0]
 8000712:	4812      	ldr	r0, [pc, #72]	; (800075c <prvAddCurrentTaskToDelayedList+0x7c>)
 8000714:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8000716:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800071a:	f000 baaf 	b.w	8000c7c <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 800071e:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8000720:	681a      	ldr	r2, [r3, #0]

			if( xTimeToWake < xConstTickCount )
 8000722:	42a5      	cmp	r5, r4
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8000724:	6054      	str	r4, [r2, #4]

			if( xTimeToWake < xConstTickCount )
 8000726:	d907      	bls.n	8000738 <prvAddCurrentTaskToDelayedList+0x58>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000728:	4a0d      	ldr	r2, [pc, #52]	; (8000760 <prvAddCurrentTaskToDelayedList+0x80>)
 800072a:	6810      	ldr	r0, [r2, #0]
 800072c:	6819      	ldr	r1, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800072e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000732:	3104      	adds	r1, #4
 8000734:	f000 baae 	b.w	8000c94 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8000738:	4a0a      	ldr	r2, [pc, #40]	; (8000764 <prvAddCurrentTaskToDelayedList+0x84>)
 800073a:	6810      	ldr	r0, [r2, #0]
 800073c:	6819      	ldr	r1, [r3, #0]
 800073e:	3104      	adds	r1, #4
 8000740:	f000 faa8 	bl	8000c94 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 8000744:	4b08      	ldr	r3, [pc, #32]	; (8000768 <prvAddCurrentTaskToDelayedList+0x88>)
 8000746:	681a      	ldr	r2, [r3, #0]
 8000748:	4294      	cmp	r4, r2
				{
					xNextTaskUnblockTime = xTimeToWake;
 800074a:	bf38      	it	cc
 800074c:	601c      	strcc	r4, [r3, #0]
 800074e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000750:	2000150c 	.word	0x2000150c
 8000754:	20001428 	.word	0x20001428
 8000758:	200014a8 	.word	0x200014a8
 800075c:	200014f8 	.word	0x200014f8
 8000760:	20001430 	.word	0x20001430
 8000764:	2000142c 	.word	0x2000142c
 8000768:	200014d8 	.word	0x200014d8

0800076c <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 800076c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000770:	ea4f 0a82 	mov.w	sl, r2, lsl #2
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8000774:	4680      	mov	r8, r0
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000776:	4650      	mov	r0, sl
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8000778:	460f      	mov	r7, r1
 800077a:	4699      	mov	r9, r3
 800077c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800077e:	f7ff fe2f 	bl	80003e0 <pvPortMalloc>

			if( pxStack != NULL )
 8000782:	4605      	mov	r5, r0
 8000784:	2800      	cmp	r0, #0
 8000786:	f000 8099 	beq.w	80008bc <xTaskCreate+0x150>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800078a:	204c      	movs	r0, #76	; 0x4c
 800078c:	f7ff fe28 	bl	80003e0 <pvPortMalloc>

				if( pxNewTCB != NULL )
 8000790:	4604      	mov	r4, r0
 8000792:	2800      	cmp	r0, #0
 8000794:	f000 808f 	beq.w	80008b6 <xTaskCreate+0x14a>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8000798:	f1aa 0a04 	sub.w	sl, sl, #4
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */

				if( pxNewTCB != NULL )
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 800079c:	6305      	str	r5, [r0, #48]	; 0x30
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800079e:	4455      	add	r5, sl
 80007a0:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80007a2:	f025 0a07 	bic.w	sl, r5, #7
 80007a6:	f100 0234 	add.w	r2, r0, #52	; 0x34
 80007aa:	370f      	adds	r7, #15
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80007ac:	7859      	ldrb	r1, [r3, #1]
 80007ae:	f802 1b01 	strb.w	r1, [r2], #1

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80007b2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80007b6:	b109      	cbz	r1, 80007bc <xTaskCreate+0x50>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80007b8:	42bb      	cmp	r3, r7
 80007ba:	d1f7      	bne.n	80007ac <xTaskCreate+0x40>
 80007bc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80007be:	2d04      	cmp	r5, #4
 80007c0:	bf28      	it	cs
 80007c2:	2504      	movcs	r5, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80007c4:	f04f 0b00 	mov.w	fp, #0
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80007c8:	1d27      	adds	r7, r4, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 80007ca:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80007cc:	4638      	mov	r0, r7
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80007ce:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80007d2:	f000 fa50 	bl	8000c76 <vListInitialiseItem>
	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80007d6:	f1c5 0505 	rsb	r5, r5, #5
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80007da:	f104 0018 	add.w	r0, r4, #24
 80007de:	f000 fa4a 	bl	8000c76 <vListInitialiseItem>
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 80007e2:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80007e6:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80007e8:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80007ea:	6264      	str	r4, [r4, #36]	; 0x24
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80007ec:	f884 b048 	strb.w	fp, [r4, #72]	; 0x48
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80007f0:	464a      	mov	r2, r9
 80007f2:	4641      	mov	r1, r8
 80007f4:	4650      	mov	r0, sl
 80007f6:	f7ff fe91 	bl	800051c <pxPortInitialiseStack>
 80007fa:	6020      	str	r0, [r4, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 80007fc:	b106      	cbz	r6, 8000800 <xTaskCreate+0x94>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80007fe:	6034      	str	r4, [r6, #0]

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8000800:	f7ff feb8 	bl	8000574 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8000804:	4b34      	ldr	r3, [pc, #208]	; (80008d8 <xTaskCreate+0x16c>)
		if( pxCurrentTCB == NULL )
 8000806:	4e35      	ldr	r6, [pc, #212]	; (80008dc <xTaskCreate+0x170>)
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
	{
		uxCurrentNumberOfTasks++;
 8000808:	681a      	ldr	r2, [r3, #0]
 800080a:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8000914 <xTaskCreate+0x1a8>
 800080e:	3201      	adds	r2, #1
 8000810:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8000812:	6832      	ldr	r2, [r6, #0]
 8000814:	2a00      	cmp	r2, #0
 8000816:	d154      	bne.n	80008c2 <xTaskCreate+0x156>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 8000818:	6034      	str	r4, [r6, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800081a:	681b      	ldr	r3, [r3, #0]
 800081c:	2b01      	cmp	r3, #1
 800081e:	d122      	bne.n	8000866 <xTaskCreate+0xfa>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8000820:	482f      	ldr	r0, [pc, #188]	; (80008e0 <xTaskCreate+0x174>)
	}

	vListInitialise( &xDelayedTaskList1 );
 8000822:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 8000918 <xTaskCreate+0x1ac>
	vListInitialise( &xDelayedTaskList2 );
 8000826:	4d2f      	ldr	r5, [pc, #188]	; (80008e4 <xTaskCreate+0x178>)
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8000828:	f000 fa1a 	bl	8000c60 <vListInitialise>
 800082c:	482e      	ldr	r0, [pc, #184]	; (80008e8 <xTaskCreate+0x17c>)
 800082e:	f000 fa17 	bl	8000c60 <vListInitialise>
 8000832:	482e      	ldr	r0, [pc, #184]	; (80008ec <xTaskCreate+0x180>)
 8000834:	f000 fa14 	bl	8000c60 <vListInitialise>
 8000838:	482d      	ldr	r0, [pc, #180]	; (80008f0 <xTaskCreate+0x184>)
 800083a:	f000 fa11 	bl	8000c60 <vListInitialise>
 800083e:	482d      	ldr	r0, [pc, #180]	; (80008f4 <xTaskCreate+0x188>)
 8000840:	f000 fa0e 	bl	8000c60 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 8000844:	4648      	mov	r0, r9
 8000846:	f000 fa0b 	bl	8000c60 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800084a:	4628      	mov	r0, r5
 800084c:	f000 fa08 	bl	8000c60 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8000850:	4829      	ldr	r0, [pc, #164]	; (80008f8 <xTaskCreate+0x18c>)
 8000852:	f000 fa05 	bl	8000c60 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8000856:	4829      	ldr	r0, [pc, #164]	; (80008fc <xTaskCreate+0x190>)
 8000858:	f000 fa02 	bl	8000c60 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800085c:	4b28      	ldr	r3, [pc, #160]	; (8000900 <xTaskCreate+0x194>)
 800085e:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000862:	4b28      	ldr	r3, [pc, #160]	; (8000904 <xTaskCreate+0x198>)
 8000864:	601d      	str	r5, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 8000866:	4a28      	ldr	r2, [pc, #160]	; (8000908 <xTaskCreate+0x19c>)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8000868:	4928      	ldr	r1, [pc, #160]	; (800090c <xTaskCreate+0x1a0>)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800086a:	6813      	ldr	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 800086c:	6808      	ldr	r0, [r1, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800086e:	3301      	adds	r3, #1
 8000870:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8000872:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000874:	2501      	movs	r5, #1
 8000876:	fa05 f302 	lsl.w	r3, r5, r2
 800087a:	4303      	orrs	r3, r0
 800087c:	600b      	str	r3, [r1, #0]
 800087e:	4b18      	ldr	r3, [pc, #96]	; (80008e0 <xTaskCreate+0x174>)
 8000880:	2014      	movs	r0, #20
 8000882:	fb00 3002 	mla	r0, r0, r2, r3
 8000886:	4639      	mov	r1, r7
 8000888:	f000 f9f8 	bl	8000c7c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 800088c:	f7ff fe82 	bl	8000594 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8000890:	f8d8 3000 	ldr.w	r3, [r8]
 8000894:	b163      	cbz	r3, 80008b0 <xTaskCreate+0x144>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8000896:	6833      	ldr	r3, [r6, #0]
 8000898:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800089a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800089c:	429a      	cmp	r2, r3
 800089e:	d207      	bcs.n	80008b0 <xTaskCreate+0x144>
		{
			taskYIELD_IF_USING_PREEMPTION();
 80008a0:	4b1b      	ldr	r3, [pc, #108]	; (8000910 <xTaskCreate+0x1a4>)
 80008a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80008a6:	601a      	str	r2, [r3, #0]
 80008a8:	f3bf 8f4f 	dsb	sy
 80008ac:	f3bf 8f6f 	isb	sy
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
 80008b0:	4628      	mov	r0, r5
 80008b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 80008b6:	4628      	mov	r0, r5
 80008b8:	f7ff fdec 	bl	8000494 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80008bc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 80008c0:	e7f6      	b.n	80008b0 <xTaskCreate+0x144>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 80008c2:	f8d8 3000 	ldr.w	r3, [r8]
 80008c6:	2b00      	cmp	r3, #0
 80008c8:	d1cd      	bne.n	8000866 <xTaskCreate+0xfa>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80008ca:	6833      	ldr	r3, [r6, #0]
 80008cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80008ce:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80008d0:	429a      	cmp	r2, r3
				{
					pxCurrentTCB = pxNewTCB;
 80008d2:	bf98      	it	ls
 80008d4:	6034      	strls	r4, [r6, #0]
 80008d6:	e7c6      	b.n	8000866 <xTaskCreate+0xfa>
 80008d8:	20001498 	.word	0x20001498
 80008dc:	20001428 	.word	0x20001428
 80008e0:	20001434 	.word	0x20001434
 80008e4:	200014c0 	.word	0x200014c0
 80008e8:	20001448 	.word	0x20001448
 80008ec:	2000145c 	.word	0x2000145c
 80008f0:	20001470 	.word	0x20001470
 80008f4:	20001484 	.word	0x20001484
 80008f8:	200014e0 	.word	0x200014e0
 80008fc:	200014f8 	.word	0x200014f8
 8000900:	2000142c 	.word	0x2000142c
 8000904:	20001430 	.word	0x20001430
 8000908:	200014a4 	.word	0x200014a4
 800090c:	200014a8 	.word	0x200014a8
 8000910:	e000ed04 	.word	0xe000ed04
 8000914:	200014f4 	.word	0x200014f4
 8000918:	200014ac 	.word	0x200014ac

0800091c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800091c:	b513      	push	{r0, r1, r4, lr}
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 800091e:	4b11      	ldr	r3, [pc, #68]	; (8000964 <vTaskStartScheduler+0x48>)
 8000920:	9301      	str	r3, [sp, #4]
 8000922:	2400      	movs	r4, #0
 8000924:	9400      	str	r4, [sp, #0]
 8000926:	4623      	mov	r3, r4
 8000928:	220a      	movs	r2, #10
 800092a:	490f      	ldr	r1, [pc, #60]	; (8000968 <vTaskStartScheduler+0x4c>)
 800092c:	480f      	ldr	r0, [pc, #60]	; (800096c <vTaskStartScheduler+0x50>)
 800092e:	f7ff ff1d 	bl	800076c <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8000932:	2801      	cmp	r0, #1
 8000934:	d114      	bne.n	8000960 <vTaskStartScheduler+0x44>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8000936:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 800093a:	f383 8811 	msr	BASEPRI, r3
 800093e:	f3bf 8f6f 	isb	sy
 8000942:	f3bf 8f4f 	dsb	sy
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 8000946:	4b0a      	ldr	r3, [pc, #40]	; (8000970 <vTaskStartScheduler+0x54>)
 8000948:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800094c:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800094e:	4b09      	ldr	r3, [pc, #36]	; (8000974 <vTaskStartScheduler+0x58>)
 8000950:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8000952:	4b09      	ldr	r3, [pc, #36]	; (8000978 <vTaskStartScheduler+0x5c>)
 8000954:	601c      	str	r4, [r3, #0]
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8000956:	b002      	add	sp, #8
 8000958:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800095c:	f7ff be7c 	b.w	8000658 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8000960:	b002      	add	sp, #8
 8000962:	bd10      	pop	{r4, pc}
 8000964:	200014d4 	.word	0x200014d4
 8000968:	08001239 	.word	0x08001239
 800096c:	08000699 	.word	0x08000699
 8000970:	200014d8 	.word	0x200014d8
 8000974:	200014f4 	.word	0x200014f4
 8000978:	2000150c 	.word	0x2000150c

0800097c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800097c:	4a02      	ldr	r2, [pc, #8]	; (8000988 <vTaskSuspendAll+0xc>)
 800097e:	6813      	ldr	r3, [r2, #0]
 8000980:	3301      	adds	r3, #1
 8000982:	6013      	str	r3, [r2, #0]
 8000984:	4770      	bx	lr
 8000986:	bf00      	nop
 8000988:	200014a0 	.word	0x200014a0

0800098c <xTaskGetTickCount>:
 800098c:	4b01      	ldr	r3, [pc, #4]	; (8000994 <xTaskGetTickCount+0x8>)
 800098e:	6818      	ldr	r0, [r3, #0]
 8000990:	4770      	bx	lr
 8000992:	bf00      	nop
 8000994:	2000150c 	.word	0x2000150c

08000998 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8000998:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800099c:	4b36      	ldr	r3, [pc, #216]	; (8000a78 <xTaskIncrementTick+0xe0>)
 800099e:	681b      	ldr	r3, [r3, #0]
 80009a0:	2b00      	cmp	r3, #0
 80009a2:	d147      	bne.n	8000a34 <xTaskIncrementTick+0x9c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 80009a4:	4b35      	ldr	r3, [pc, #212]	; (8000a7c <xTaskIncrementTick+0xe4>)
 80009a6:	681c      	ldr	r4, [r3, #0]
 80009a8:	3401      	adds	r4, #1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 80009aa:	601c      	str	r4, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
 80009ac:	b95c      	cbnz	r4, 80009c6 <xTaskIncrementTick+0x2e>
		{
			taskSWITCH_DELAYED_LISTS();
 80009ae:	4a34      	ldr	r2, [pc, #208]	; (8000a80 <xTaskIncrementTick+0xe8>)
 80009b0:	4b34      	ldr	r3, [pc, #208]	; (8000a84 <xTaskIncrementTick+0xec>)
 80009b2:	6811      	ldr	r1, [r2, #0]
 80009b4:	6818      	ldr	r0, [r3, #0]
 80009b6:	6010      	str	r0, [r2, #0]
 80009b8:	4a33      	ldr	r2, [pc, #204]	; (8000a88 <xTaskIncrementTick+0xf0>)
 80009ba:	6019      	str	r1, [r3, #0]
 80009bc:	6813      	ldr	r3, [r2, #0]
 80009be:	3301      	adds	r3, #1
 80009c0:	6013      	str	r3, [r2, #0]
 80009c2:	f7ff fe7b 	bl	80006bc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 80009c6:	4d31      	ldr	r5, [pc, #196]	; (8000a8c <xTaskIncrementTick+0xf4>)
 80009c8:	4f31      	ldr	r7, [pc, #196]	; (8000a90 <xTaskIncrementTick+0xf8>)
 80009ca:	682b      	ldr	r3, [r5, #0]
 80009cc:	429c      	cmp	r4, r3
 80009ce:	f04f 0b00 	mov.w	fp, #0
 80009d2:	d33e      	bcc.n	8000a52 <xTaskIncrementTick+0xba>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80009d4:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8000a80 <xTaskIncrementTick+0xe8>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 80009d8:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8000aa0 <xTaskIncrementTick+0x108>
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80009dc:	f8d8 2000 	ldr.w	r2, [r8]
 80009e0:	6812      	ldr	r2, [r2, #0]
 80009e2:	bb72      	cbnz	r2, 8000a42 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80009e4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80009e8:	602a      	str	r2, [r5, #0]
					break;
 80009ea:	e032      	b.n	8000a52 <xTaskIncrementTick+0xba>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80009ec:	f106 0a04 	add.w	sl, r6, #4
 80009f0:	4650      	mov	r0, sl
 80009f2:	f000 f966 	bl	8000cc2 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80009f6:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 80009f8:	b119      	cbz	r1, 8000a02 <xTaskIncrementTick+0x6a>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80009fa:	f106 0018 	add.w	r0, r6, #24
 80009fe:	f000 f960 	bl	8000cc2 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 8000a02:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8000a04:	f8d9 3000 	ldr.w	r3, [r9]
 8000a08:	2201      	movs	r2, #1
 8000a0a:	fa02 f100 	lsl.w	r1, r2, r0
 8000a0e:	4319      	orrs	r1, r3
 8000a10:	4b20      	ldr	r3, [pc, #128]	; (8000a94 <xTaskIncrementTick+0xfc>)
 8000a12:	f8c9 1000 	str.w	r1, [r9]
 8000a16:	f04f 0e14 	mov.w	lr, #20
 8000a1a:	4651      	mov	r1, sl
 8000a1c:	fb0e 3000 	mla	r0, lr, r0, r3
 8000a20:	f000 f92c 	bl	8000c7c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000a24:	6838      	ldr	r0, [r7, #0]
 8000a26:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8000a28:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
						{
							xSwitchRequired = pdTRUE;
 8000a2a:	4291      	cmp	r1, r2
 8000a2c:	bf28      	it	cs
 8000a2e:	f04f 0b01 	movcs.w	fp, #1
 8000a32:	e7d3      	b.n	80009dc <xTaskIncrementTick+0x44>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8000a34:	4a18      	ldr	r2, [pc, #96]	; (8000a98 <xTaskIncrementTick+0x100>)
 8000a36:	6813      	ldr	r3, [r2, #0]
 8000a38:	3301      	adds	r3, #1
 8000a3a:	6013      	str	r3, [r2, #0]

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8000a3c:	f04f 0b00 	mov.w	fp, #0
 8000a40:	e011      	b.n	8000a66 <xTaskIncrementTick+0xce>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8000a42:	f8d8 2000 	ldr.w	r2, [r8]
 8000a46:	68d2      	ldr	r2, [r2, #12]
 8000a48:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8000a4a:	6871      	ldr	r1, [r6, #4]

					if( xConstTickCount < xItemValue )
 8000a4c:	428c      	cmp	r4, r1
 8000a4e:	d2cd      	bcs.n	80009ec <xTaskIncrementTick+0x54>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 8000a50:	6029      	str	r1, [r5, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8000a52:	683a      	ldr	r2, [r7, #0]
 8000a54:	4b0f      	ldr	r3, [pc, #60]	; (8000a94 <xTaskIncrementTick+0xfc>)
 8000a56:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8000a58:	2214      	movs	r2, #20
 8000a5a:	434a      	muls	r2, r1
 8000a5c:	589a      	ldr	r2, [r3, r2]
			{
				xSwitchRequired = pdTRUE;
 8000a5e:	2a02      	cmp	r2, #2
 8000a60:	bf28      	it	cs
 8000a62:	f04f 0b01 	movcs.w	fp, #1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8000a66:	4a0d      	ldr	r2, [pc, #52]	; (8000a9c <xTaskIncrementTick+0x104>)
 8000a68:	6812      	ldr	r2, [r2, #0]
		{
			xSwitchRequired = pdTRUE;
 8000a6a:	2a00      	cmp	r2, #0
 8000a6c:	bf18      	it	ne
 8000a6e:	f04f 0b01 	movne.w	fp, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 8000a72:	4658      	mov	r0, fp
 8000a74:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a78:	200014a0 	.word	0x200014a0
 8000a7c:	2000150c 	.word	0x2000150c
 8000a80:	2000142c 	.word	0x2000142c
 8000a84:	20001430 	.word	0x20001430
 8000a88:	200014dc 	.word	0x200014dc
 8000a8c:	200014d8 	.word	0x200014d8
 8000a90:	20001428 	.word	0x20001428
 8000a94:	20001434 	.word	0x20001434
 8000a98:	2000149c 	.word	0x2000149c
 8000a9c:	20001510 	.word	0x20001510
 8000aa0:	200014a8 	.word	0x200014a8

08000aa4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8000aa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8000aa8:	f7ff fd64 	bl	8000574 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8000aac:	4b2a      	ldr	r3, [pc, #168]	; (8000b58 <xTaskResumeAll+0xb4>)
 8000aae:	681a      	ldr	r2, [r3, #0]
 8000ab0:	3a01      	subs	r2, #1
 8000ab2:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000ab4:	681c      	ldr	r4, [r3, #0]
 8000ab6:	b12c      	cbz	r4, 8000ac4 <xTaskResumeAll+0x20>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
 8000ab8:	2400      	movs	r4, #0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8000aba:	f7ff fd6b 	bl	8000594 <vPortExitCritical>

	return xAlreadyYielded;
}
 8000abe:	4620      	mov	r0, r4
 8000ac0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8000ac4:	4b25      	ldr	r3, [pc, #148]	; (8000b5c <xTaskResumeAll+0xb8>)
 8000ac6:	681b      	ldr	r3, [r3, #0]
 8000ac8:	2b00      	cmp	r3, #0
 8000aca:	d0f5      	beq.n	8000ab8 <xTaskResumeAll+0x14>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000acc:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8000b74 <xTaskResumeAll+0xd0>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
 8000ad0:	4f23      	ldr	r7, [pc, #140]	; (8000b60 <xTaskResumeAll+0xbc>)
 8000ad2:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8000b78 <xTaskResumeAll+0xd4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000ad6:	f8d9 3000 	ldr.w	r3, [r9]
 8000ada:	b9e3      	cbnz	r3, 8000b16 <xTaskResumeAll+0x72>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 8000adc:	b10c      	cbz	r4, 8000ae2 <xTaskResumeAll+0x3e>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 8000ade:	f7ff fded 	bl	80006bc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8000ae2:	4d20      	ldr	r5, [pc, #128]	; (8000b64 <xTaskResumeAll+0xc0>)
 8000ae4:	682c      	ldr	r4, [r5, #0]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8000ae6:	b144      	cbz	r4, 8000afa <xTaskResumeAll+0x56>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
 8000ae8:	4e1f      	ldr	r6, [pc, #124]	; (8000b68 <xTaskResumeAll+0xc4>)
 8000aea:	2701      	movs	r7, #1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 8000aec:	f7ff ff54 	bl	8000998 <xTaskIncrementTick>
 8000af0:	b100      	cbz	r0, 8000af4 <xTaskResumeAll+0x50>
							{
								xYieldPending = pdTRUE;
 8000af2:	6037      	str	r7, [r6, #0]
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8000af4:	3c01      	subs	r4, #1
 8000af6:	d1f9      	bne.n	8000aec <xTaskResumeAll+0x48>

						uxPendedTicks = 0;
 8000af8:	602c      	str	r4, [r5, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 8000afa:	4b1b      	ldr	r3, [pc, #108]	; (8000b68 <xTaskResumeAll+0xc4>)
 8000afc:	681b      	ldr	r3, [r3, #0]
 8000afe:	2b00      	cmp	r3, #0
 8000b00:	d0da      	beq.n	8000ab8 <xTaskResumeAll+0x14>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8000b02:	4b1a      	ldr	r3, [pc, #104]	; (8000b6c <xTaskResumeAll+0xc8>)
 8000b04:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000b08:	601a      	str	r2, [r3, #0]
 8000b0a:	f3bf 8f4f 	dsb	sy
 8000b0e:	f3bf 8f6f 	isb	sy

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 8000b12:	2401      	movs	r4, #1
 8000b14:	e7d1      	b.n	8000aba <xTaskResumeAll+0x16>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8000b16:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8000b1a:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000b1c:	1d26      	adds	r6, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8000b1e:	f104 0018 	add.w	r0, r4, #24
 8000b22:	f000 f8ce 	bl	8000cc2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000b26:	4630      	mov	r0, r6
 8000b28:	f000 f8cb 	bl	8000cc2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000b2c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000b2e:	6839      	ldr	r1, [r7, #0]
 8000b30:	2501      	movs	r5, #1
 8000b32:	fa05 f302 	lsl.w	r3, r5, r2
 8000b36:	2014      	movs	r0, #20
 8000b38:	430b      	orrs	r3, r1
 8000b3a:	fb00 8002 	mla	r0, r0, r2, r8
 8000b3e:	4631      	mov	r1, r6
 8000b40:	603b      	str	r3, [r7, #0]
 8000b42:	f000 f89b 	bl	8000c7c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000b46:	4b0a      	ldr	r3, [pc, #40]	; (8000b70 <xTaskResumeAll+0xcc>)
 8000b48:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000b4e:	429a      	cmp	r2, r3
					{
						xYieldPending = pdTRUE;
 8000b50:	bf24      	itt	cs
 8000b52:	4b05      	ldrcs	r3, [pc, #20]	; (8000b68 <xTaskResumeAll+0xc4>)
 8000b54:	601d      	strcs	r5, [r3, #0]
 8000b56:	e7be      	b.n	8000ad6 <xTaskResumeAll+0x32>
 8000b58:	200014a0 	.word	0x200014a0
 8000b5c:	20001498 	.word	0x20001498
 8000b60:	200014a8 	.word	0x200014a8
 8000b64:	2000149c 	.word	0x2000149c
 8000b68:	20001510 	.word	0x20001510
 8000b6c:	e000ed04 	.word	0xe000ed04
 8000b70:	20001428 	.word	0x20001428
 8000b74:	200014e0 	.word	0x200014e0
 8000b78:	20001434 	.word	0x20001434

08000b7c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 8000b7c:	b510      	push	{r4, lr}

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 8000b7e:	f7ff fefd 	bl	800097c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 8000b82:	4b12      	ldr	r3, [pc, #72]	; (8000bcc <vTaskDelayUntil+0x50>)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8000b84:	6804      	ldr	r4, [r0, #0]

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 8000b86:	681a      	ldr	r2, [r3, #0]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xConstTickCount < *pxPreviousWakeTime )
 8000b88:	42a2      	cmp	r2, r4
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8000b8a:	eb04 0301 	add.w	r3, r4, r1

			if( xConstTickCount < *pxPreviousWakeTime )
 8000b8e:	d217      	bcs.n	8000bc0 <vTaskDelayUntil+0x44>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 8000b90:	429c      	cmp	r4, r3
 8000b92:	d919      	bls.n	8000bc8 <vTaskDelayUntil+0x4c>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 8000b94:	429a      	cmp	r2, r3
 8000b96:	bf2c      	ite	cs
 8000b98:	2100      	movcs	r1, #0
 8000b9a:	2101      	movcc	r1, #1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8000b9c:	6003      	str	r3, [r0, #0]

			if( xShouldDelay != pdFALSE )
 8000b9e:	b119      	cbz	r1, 8000ba8 <vTaskDelayUntil+0x2c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 8000ba0:	2100      	movs	r1, #0
 8000ba2:	1a98      	subs	r0, r3, r2
 8000ba4:	f7ff fd9c 	bl	80006e0 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8000ba8:	f7ff ff7c 	bl	8000aa4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8000bac:	b938      	cbnz	r0, 8000bbe <vTaskDelayUntil+0x42>
		{
			portYIELD_WITHIN_API();
 8000bae:	4b08      	ldr	r3, [pc, #32]	; (8000bd0 <vTaskDelayUntil+0x54>)
 8000bb0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000bb4:	601a      	str	r2, [r3, #0]
 8000bb6:	f3bf 8f4f 	dsb	sy
 8000bba:	f3bf 8f6f 	isb	sy
 8000bbe:	bd10      	pop	{r4, pc}
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 8000bc0:	429c      	cmp	r4, r3
 8000bc2:	d9e7      	bls.n	8000b94 <vTaskDelayUntil+0x18>
				{
					xShouldDelay = pdTRUE;
 8000bc4:	2101      	movs	r1, #1
 8000bc6:	e7e9      	b.n	8000b9c <vTaskDelayUntil+0x20>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 8000bc8:	2100      	movs	r1, #0
 8000bca:	e7e7      	b.n	8000b9c <vTaskDelayUntil+0x20>
 8000bcc:	2000150c 	.word	0x2000150c
 8000bd0:	e000ed04 	.word	0xe000ed04

08000bd4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8000bd4:	b508      	push	{r3, lr}
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8000bd6:	b940      	cbnz	r0, 8000bea <vTaskDelay+0x16>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8000bd8:	4b09      	ldr	r3, [pc, #36]	; (8000c00 <vTaskDelay+0x2c>)
 8000bda:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000bde:	601a      	str	r2, [r3, #0]
 8000be0:	f3bf 8f4f 	dsb	sy
 8000be4:	f3bf 8f6f 	isb	sy
 8000be8:	bd08      	pop	{r3, pc}

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 8000bea:	f7ff fec7 	bl	800097c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8000bee:	2100      	movs	r1, #0
 8000bf0:	f7ff fd76 	bl	80006e0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8000bf4:	f7ff ff56 	bl	8000aa4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8000bf8:	2800      	cmp	r0, #0
 8000bfa:	d0ed      	beq.n	8000bd8 <vTaskDelay+0x4>
 8000bfc:	bd08      	pop	{r3, pc}
 8000bfe:	bf00      	nop
 8000c00:	e000ed04 	.word	0xe000ed04

08000c04 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000c04:	4b11      	ldr	r3, [pc, #68]	; (8000c4c <vTaskSwitchContext+0x48>)
 8000c06:	681a      	ldr	r2, [r3, #0]
 8000c08:	4b11      	ldr	r3, [pc, #68]	; (8000c50 <vTaskSwitchContext+0x4c>)

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8000c0a:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000c0c:	b112      	cbz	r2, 8000c14 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8000c0e:	2201      	movs	r2, #1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8000c10:	601a      	str	r2, [r3, #0]
 8000c12:	bd30      	pop	{r4, r5, pc}
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 8000c14:	601a      	str	r2, [r3, #0]
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8000c16:	4b0f      	ldr	r3, [pc, #60]	; (8000c54 <vTaskSwitchContext+0x50>)
 8000c18:	681b      	ldr	r3, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8000c1a:	fab3 f383 	clz	r3, r3
 8000c1e:	b2db      	uxtb	r3, r3
 8000c20:	490d      	ldr	r1, [pc, #52]	; (8000c58 <vTaskSwitchContext+0x54>)
 8000c22:	f1c3 031f 	rsb	r3, r3, #31
 8000c26:	2014      	movs	r0, #20
 8000c28:	fb00 f203 	mul.w	r2, r0, r3
 8000c2c:	188c      	adds	r4, r1, r2
 8000c2e:	3208      	adds	r2, #8
 8000c30:	6865      	ldr	r5, [r4, #4]
 8000c32:	686d      	ldr	r5, [r5, #4]
 8000c34:	6065      	str	r5, [r4, #4]
 8000c36:	440a      	add	r2, r1
 8000c38:	4295      	cmp	r5, r2
 8000c3a:	bf04      	itt	eq
 8000c3c:	686a      	ldreq	r2, [r5, #4]
 8000c3e:	6062      	streq	r2, [r4, #4]
 8000c40:	fb00 1303 	mla	r3, r0, r3, r1
 8000c44:	685b      	ldr	r3, [r3, #4]
 8000c46:	68da      	ldr	r2, [r3, #12]
 8000c48:	4b04      	ldr	r3, [pc, #16]	; (8000c5c <vTaskSwitchContext+0x58>)
 8000c4a:	e7e1      	b.n	8000c10 <vTaskSwitchContext+0xc>
 8000c4c:	200014a0 	.word	0x200014a0
 8000c50:	20001510 	.word	0x20001510
 8000c54:	200014a8 	.word	0x200014a8
 8000c58:	20001434 	.word	0x20001434
 8000c5c:	20001428 	.word	0x20001428

08000c60 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000c60:	f100 0308 	add.w	r3, r0, #8
 8000c64:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000c66:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000c6a:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000c6c:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000c6e:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000c70:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000c72:	6003      	str	r3, [r0, #0]
 8000c74:	4770      	bx	lr

08000c76 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8000c76:	2300      	movs	r3, #0
 8000c78:	6103      	str	r3, [r0, #16]
 8000c7a:	4770      	bx	lr

08000c7c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8000c7c:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8000c7e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8000c80:	689a      	ldr	r2, [r3, #8]
 8000c82:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8000c84:	689a      	ldr	r2, [r3, #8]
 8000c86:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8000c88:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8000c8a:	6803      	ldr	r3, [r0, #0]

	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000c8c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8000c8e:	3301      	adds	r3, #1
 8000c90:	6003      	str	r3, [r0, #0]
 8000c92:	4770      	bx	lr

08000c94 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8000c94:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000c96:	1c53      	adds	r3, r2, #1
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8000c98:	b530      	push	{r4, r5, lr}
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000c9a:	d10a      	bne.n	8000cb2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8000c9c:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8000c9e:	685a      	ldr	r2, [r3, #4]
 8000ca0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000ca2:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8000ca4:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8000ca6:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8000ca8:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000caa:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8000cac:	3301      	adds	r3, #1
 8000cae:	6003      	str	r3, [r0, #0]
 8000cb0:	bd30      	pop	{r4, r5, pc}
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000cb2:	f100 0308 	add.w	r3, r0, #8
 8000cb6:	685c      	ldr	r4, [r3, #4]
 8000cb8:	6825      	ldr	r5, [r4, #0]
 8000cba:	42aa      	cmp	r2, r5
 8000cbc:	d3ef      	bcc.n	8000c9e <vListInsert+0xa>
 8000cbe:	4623      	mov	r3, r4
 8000cc0:	e7f9      	b.n	8000cb6 <vListInsert+0x22>

08000cc2 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000cc2:	6841      	ldr	r1, [r0, #4]
 8000cc4:	6882      	ldr	r2, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8000cc6:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000cc8:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000cca:	6882      	ldr	r2, [r0, #8]
 8000ccc:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000cce:	6859      	ldr	r1, [r3, #4]
 8000cd0:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000cd2:	bf08      	it	eq
 8000cd4:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8000cd6:	2200      	movs	r2, #0
 8000cd8:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8000cda:	6818      	ldr	r0, [r3, #0]
 8000cdc:	3801      	subs	r0, #1
 8000cde:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8000ce0:	4770      	bx	lr
	...

08000ce4 <rcc_is_osc_ready>:
 8000ce4:	2806      	cmp	r0, #6
 8000ce6:	d822      	bhi.n	8000d2e <rcc_is_osc_ready+0x4a>
 8000ce8:	e8df f000 	tbb	[pc, r0]
 8000cec:	091c1704 	.word	0x091c1704
 8000cf0:	130e      	.short	0x130e
 8000cf2:	15          	.byte	0x15
 8000cf3:	00          	.byte	0x00
 8000cf4:	4b0f      	ldr	r3, [pc, #60]	; (8000d34 <rcc_is_osc_ready+0x50>)
 8000cf6:	6818      	ldr	r0, [r3, #0]
 8000cf8:	f3c0 6040 	ubfx	r0, r0, #25, #1
 8000cfc:	4770      	bx	lr
 8000cfe:	4b0d      	ldr	r3, [pc, #52]	; (8000d34 <rcc_is_osc_ready+0x50>)
 8000d00:	6818      	ldr	r0, [r3, #0]
 8000d02:	f3c0 4040 	ubfx	r0, r0, #17, #1
 8000d06:	4770      	bx	lr
 8000d08:	4b0a      	ldr	r3, [pc, #40]	; (8000d34 <rcc_is_osc_ready+0x50>)
 8000d0a:	6818      	ldr	r0, [r3, #0]
 8000d0c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8000d10:	4770      	bx	lr
 8000d12:	4b09      	ldr	r3, [pc, #36]	; (8000d38 <rcc_is_osc_ready+0x54>)
 8000d14:	e7f9      	b.n	8000d0a <rcc_is_osc_ready+0x26>
 8000d16:	4b09      	ldr	r3, [pc, #36]	; (8000d3c <rcc_is_osc_ready+0x58>)
 8000d18:	e7f7      	b.n	8000d0a <rcc_is_osc_ready+0x26>
 8000d1a:	4b06      	ldr	r3, [pc, #24]	; (8000d34 <rcc_is_osc_ready+0x50>)
 8000d1c:	6818      	ldr	r0, [r3, #0]
 8000d1e:	f3c0 7040 	ubfx	r0, r0, #29, #1
 8000d22:	4770      	bx	lr
 8000d24:	4b03      	ldr	r3, [pc, #12]	; (8000d34 <rcc_is_osc_ready+0x50>)
 8000d26:	6818      	ldr	r0, [r3, #0]
 8000d28:	f3c0 60c0 	ubfx	r0, r0, #27, #1
 8000d2c:	4770      	bx	lr
 8000d2e:	2000      	movs	r0, #0
 8000d30:	4770      	bx	lr
 8000d32:	bf00      	nop
 8000d34:	40023800 	.word	0x40023800
 8000d38:	40023870 	.word	0x40023870
 8000d3c:	40023874 	.word	0x40023874

08000d40 <rcc_wait_for_osc_ready>:
 8000d40:	b508      	push	{r3, lr}
 8000d42:	4602      	mov	r2, r0
 8000d44:	4610      	mov	r0, r2
 8000d46:	f7ff ffcd 	bl	8000ce4 <rcc_is_osc_ready>
 8000d4a:	2800      	cmp	r0, #0
 8000d4c:	d0fa      	beq.n	8000d44 <rcc_wait_for_osc_ready+0x4>
 8000d4e:	bd08      	pop	{r3, pc}

08000d50 <rcc_osc_on>:
 8000d50:	2806      	cmp	r0, #6
 8000d52:	d80a      	bhi.n	8000d6a <rcc_osc_on+0x1a>
 8000d54:	e8df f000 	tbb	[pc, r0]
 8000d58:	0a1d1804 	.word	0x0a1d1804
 8000d5c:	140f      	.short	0x140f
 8000d5e:	16          	.byte	0x16
 8000d5f:	00          	.byte	0x00
 8000d60:	4a0e      	ldr	r2, [pc, #56]	; (8000d9c <rcc_osc_on+0x4c>)
 8000d62:	6813      	ldr	r3, [r2, #0]
 8000d64:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000d68:	6013      	str	r3, [r2, #0]
 8000d6a:	4770      	bx	lr
 8000d6c:	4a0b      	ldr	r2, [pc, #44]	; (8000d9c <rcc_osc_on+0x4c>)
 8000d6e:	6813      	ldr	r3, [r2, #0]
 8000d70:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000d74:	e7f8      	b.n	8000d68 <rcc_osc_on+0x18>
 8000d76:	4a09      	ldr	r2, [pc, #36]	; (8000d9c <rcc_osc_on+0x4c>)
 8000d78:	6813      	ldr	r3, [r2, #0]
 8000d7a:	f043 0301 	orr.w	r3, r3, #1
 8000d7e:	e7f3      	b.n	8000d68 <rcc_osc_on+0x18>
 8000d80:	4a07      	ldr	r2, [pc, #28]	; (8000da0 <rcc_osc_on+0x50>)
 8000d82:	e7f9      	b.n	8000d78 <rcc_osc_on+0x28>
 8000d84:	4a07      	ldr	r2, [pc, #28]	; (8000da4 <rcc_osc_on+0x54>)
 8000d86:	e7f7      	b.n	8000d78 <rcc_osc_on+0x28>
 8000d88:	4a04      	ldr	r2, [pc, #16]	; (8000d9c <rcc_osc_on+0x4c>)
 8000d8a:	6813      	ldr	r3, [r2, #0]
 8000d8c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000d90:	e7ea      	b.n	8000d68 <rcc_osc_on+0x18>
 8000d92:	4a02      	ldr	r2, [pc, #8]	; (8000d9c <rcc_osc_on+0x4c>)
 8000d94:	6813      	ldr	r3, [r2, #0]
 8000d96:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8000d9a:	e7e5      	b.n	8000d68 <rcc_osc_on+0x18>
 8000d9c:	40023800 	.word	0x40023800
 8000da0:	40023870 	.word	0x40023870
 8000da4:	40023874 	.word	0x40023874

08000da8 <rcc_osc_off>:
 8000da8:	2806      	cmp	r0, #6
 8000daa:	d80a      	bhi.n	8000dc2 <rcc_osc_off+0x1a>
 8000dac:	e8df f000 	tbb	[pc, r0]
 8000db0:	0a1d1804 	.word	0x0a1d1804
 8000db4:	140f      	.short	0x140f
 8000db6:	16          	.byte	0x16
 8000db7:	00          	.byte	0x00
 8000db8:	4a0e      	ldr	r2, [pc, #56]	; (8000df4 <rcc_osc_off+0x4c>)
 8000dba:	6813      	ldr	r3, [r2, #0]
 8000dbc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8000dc0:	6013      	str	r3, [r2, #0]
 8000dc2:	4770      	bx	lr
 8000dc4:	4a0b      	ldr	r2, [pc, #44]	; (8000df4 <rcc_osc_off+0x4c>)
 8000dc6:	6813      	ldr	r3, [r2, #0]
 8000dc8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000dcc:	e7f8      	b.n	8000dc0 <rcc_osc_off+0x18>
 8000dce:	4a09      	ldr	r2, [pc, #36]	; (8000df4 <rcc_osc_off+0x4c>)
 8000dd0:	6813      	ldr	r3, [r2, #0]
 8000dd2:	f023 0301 	bic.w	r3, r3, #1
 8000dd6:	e7f3      	b.n	8000dc0 <rcc_osc_off+0x18>
 8000dd8:	4a07      	ldr	r2, [pc, #28]	; (8000df8 <rcc_osc_off+0x50>)
 8000dda:	e7f9      	b.n	8000dd0 <rcc_osc_off+0x28>
 8000ddc:	4a07      	ldr	r2, [pc, #28]	; (8000dfc <rcc_osc_off+0x54>)
 8000dde:	e7f7      	b.n	8000dd0 <rcc_osc_off+0x28>
 8000de0:	4a04      	ldr	r2, [pc, #16]	; (8000df4 <rcc_osc_off+0x4c>)
 8000de2:	6813      	ldr	r3, [r2, #0]
 8000de4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000de8:	e7ea      	b.n	8000dc0 <rcc_osc_off+0x18>
 8000dea:	4a02      	ldr	r2, [pc, #8]	; (8000df4 <rcc_osc_off+0x4c>)
 8000dec:	6813      	ldr	r3, [r2, #0]
 8000dee:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8000df2:	e7e5      	b.n	8000dc0 <rcc_osc_off+0x18>
 8000df4:	40023800 	.word	0x40023800
 8000df8:	40023870 	.word	0x40023870
 8000dfc:	40023874 	.word	0x40023874

08000e00 <rcc_set_sysclk_source>:
 8000e00:	4a03      	ldr	r2, [pc, #12]	; (8000e10 <rcc_set_sysclk_source+0x10>)
 8000e02:	6813      	ldr	r3, [r2, #0]
 8000e04:	f023 0303 	bic.w	r3, r3, #3
 8000e08:	4318      	orrs	r0, r3
 8000e0a:	6010      	str	r0, [r2, #0]
 8000e0c:	4770      	bx	lr
 8000e0e:	bf00      	nop
 8000e10:	40023808 	.word	0x40023808

08000e14 <rcc_set_ppre2>:
 8000e14:	4a03      	ldr	r2, [pc, #12]	; (8000e24 <rcc_set_ppre2+0x10>)
 8000e16:	6813      	ldr	r3, [r2, #0]
 8000e18:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000e1c:	ea43 3040 	orr.w	r0, r3, r0, lsl #13
 8000e20:	6010      	str	r0, [r2, #0]
 8000e22:	4770      	bx	lr
 8000e24:	40023808 	.word	0x40023808

08000e28 <rcc_set_ppre1>:
 8000e28:	4a03      	ldr	r2, [pc, #12]	; (8000e38 <rcc_set_ppre1+0x10>)
 8000e2a:	6813      	ldr	r3, [r2, #0]
 8000e2c:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8000e30:	ea43 2080 	orr.w	r0, r3, r0, lsl #10
 8000e34:	6010      	str	r0, [r2, #0]
 8000e36:	4770      	bx	lr
 8000e38:	40023808 	.word	0x40023808

08000e3c <rcc_set_hpre>:
 8000e3c:	4a03      	ldr	r2, [pc, #12]	; (8000e4c <rcc_set_hpre+0x10>)
 8000e3e:	6813      	ldr	r3, [r2, #0]
 8000e40:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000e44:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
 8000e48:	6010      	str	r0, [r2, #0]
 8000e4a:	4770      	bx	lr
 8000e4c:	40023808 	.word	0x40023808

08000e50 <rcc_set_main_pll_hse>:
 8000e50:	061b      	lsls	r3, r3, #24
 8000e52:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 8000e56:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 8000e5a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000e5e:	4303      	orrs	r3, r0
 8000e60:	f647 70c0 	movw	r0, #32704	; 0x7fc0
 8000e64:	ea00 1181 	and.w	r1, r0, r1, lsl #6
 8000e68:	430b      	orrs	r3, r1
 8000e6a:	0851      	lsrs	r1, r2, #1
 8000e6c:	9a00      	ldr	r2, [sp, #0]
 8000e6e:	3901      	subs	r1, #1
 8000e70:	2a02      	cmp	r2, #2
 8000e72:	ea4f 4101 	mov.w	r1, r1, lsl #16
 8000e76:	bf38      	it	cc
 8000e78:	2202      	movcc	r2, #2
 8000e7a:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 8000e7e:	0712      	lsls	r2, r2, #28
 8000e80:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
 8000e84:	430b      	orrs	r3, r1
 8000e86:	4313      	orrs	r3, r2
 8000e88:	4a01      	ldr	r2, [pc, #4]	; (8000e90 <rcc_set_main_pll_hse+0x40>)
 8000e8a:	6013      	str	r3, [r2, #0]
 8000e8c:	4770      	bx	lr
 8000e8e:	bf00      	nop
 8000e90:	40023804 	.word	0x40023804

08000e94 <rcc_clock_setup_hse_3v3>:
 8000e94:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000e96:	4604      	mov	r4, r0
 8000e98:	2004      	movs	r0, #4
 8000e9a:	f7ff ff59 	bl	8000d50 <rcc_osc_on>
 8000e9e:	2004      	movs	r0, #4
 8000ea0:	f7ff ff4e 	bl	8000d40 <rcc_wait_for_osc_ready>
 8000ea4:	2000      	movs	r0, #0
 8000ea6:	f7ff ffab 	bl	8000e00 <rcc_set_sysclk_source>
 8000eaa:	2003      	movs	r0, #3
 8000eac:	f7ff ff50 	bl	8000d50 <rcc_osc_on>
 8000eb0:	2003      	movs	r0, #3
 8000eb2:	f7ff ff45 	bl	8000d40 <rcc_wait_for_osc_ready>
 8000eb6:	7be0      	ldrb	r0, [r4, #15]
 8000eb8:	2800      	cmp	r0, #0
 8000eba:	d135      	bne.n	8000f28 <rcc_clock_setup_hse_3v3+0x94>
 8000ebc:	f000 f94c 	bl	8001158 <pwr_set_vos_scale>
 8000ec0:	7b20      	ldrb	r0, [r4, #12]
 8000ec2:	f7ff ffbb 	bl	8000e3c <rcc_set_hpre>
 8000ec6:	7b60      	ldrb	r0, [r4, #13]
 8000ec8:	f7ff ffae 	bl	8000e28 <rcc_set_ppre1>
 8000ecc:	7ba0      	ldrb	r0, [r4, #14]
 8000ece:	f7ff ffa1 	bl	8000e14 <rcc_set_ppre2>
 8000ed2:	79a5      	ldrb	r5, [r4, #6]
 8000ed4:	8861      	ldrh	r1, [r4, #2]
 8000ed6:	7963      	ldrb	r3, [r4, #5]
 8000ed8:	7922      	ldrb	r2, [r4, #4]
 8000eda:	7820      	ldrb	r0, [r4, #0]
 8000edc:	9500      	str	r5, [sp, #0]
 8000ede:	f7ff ffb7 	bl	8000e50 <rcc_set_main_pll_hse>
 8000ee2:	4a12      	ldr	r2, [pc, #72]	; (8000f2c <rcc_clock_setup_hse_3v3+0x98>)
 8000ee4:	6813      	ldr	r3, [r2, #0]
 8000ee6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000eea:	6013      	str	r3, [r2, #0]
 8000eec:	2000      	movs	r0, #0
 8000eee:	f7ff ff27 	bl	8000d40 <rcc_wait_for_osc_ready>
 8000ef2:	68a0      	ldr	r0, [r4, #8]
 8000ef4:	f000 f8ca 	bl	800108c <flash_set_ws>
 8000ef8:	2002      	movs	r0, #2
 8000efa:	f7ff ff81 	bl	8000e00 <rcc_set_sysclk_source>
 8000efe:	4a0c      	ldr	r2, [pc, #48]	; (8000f30 <rcc_clock_setup_hse_3v3+0x9c>)
 8000f00:	6813      	ldr	r3, [r2, #0]
 8000f02:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8000f06:	2b02      	cmp	r3, #2
 8000f08:	d1fa      	bne.n	8000f00 <rcc_clock_setup_hse_3v3+0x6c>
 8000f0a:	4b0a      	ldr	r3, [pc, #40]	; (8000f34 <rcc_clock_setup_hse_3v3+0xa0>)
 8000f0c:	6922      	ldr	r2, [r4, #16]
 8000f0e:	601a      	str	r2, [r3, #0]
 8000f10:	4b09      	ldr	r3, [pc, #36]	; (8000f38 <rcc_clock_setup_hse_3v3+0xa4>)
 8000f12:	6962      	ldr	r2, [r4, #20]
 8000f14:	601a      	str	r2, [r3, #0]
 8000f16:	69a2      	ldr	r2, [r4, #24]
 8000f18:	4b08      	ldr	r3, [pc, #32]	; (8000f3c <rcc_clock_setup_hse_3v3+0xa8>)
 8000f1a:	2004      	movs	r0, #4
 8000f1c:	601a      	str	r2, [r3, #0]
 8000f1e:	b003      	add	sp, #12
 8000f20:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8000f24:	f7ff bf40 	b.w	8000da8 <rcc_osc_off>
 8000f28:	2001      	movs	r0, #1
 8000f2a:	e7c7      	b.n	8000ebc <rcc_clock_setup_hse_3v3+0x28>
 8000f2c:	40023800 	.word	0x40023800
 8000f30:	40023808 	.word	0x40023808
 8000f34:	20000008 	.word	0x20000008
 8000f38:	2000000c 	.word	0x2000000c
 8000f3c:	20000010 	.word	0x20000010

08000f40 <gpio_set>:
 8000f40:	6181      	str	r1, [r0, #24]
 8000f42:	4770      	bx	lr

08000f44 <gpio_clear>:
 8000f44:	0409      	lsls	r1, r1, #16
 8000f46:	6181      	str	r1, [r0, #24]
 8000f48:	4770      	bx	lr

08000f4a <gpio_mode_setup>:
 8000f4a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000f4e:	6805      	ldr	r5, [r0, #0]
 8000f50:	68c4      	ldr	r4, [r0, #12]
 8000f52:	2600      	movs	r6, #0
 8000f54:	f04f 0c03 	mov.w	ip, #3
 8000f58:	fa43 f706 	asr.w	r7, r3, r6
 8000f5c:	07ff      	lsls	r7, r7, #31
 8000f5e:	d50f      	bpl.n	8000f80 <gpio_mode_setup+0x36>
 8000f60:	0077      	lsls	r7, r6, #1
 8000f62:	fa0c fe07 	lsl.w	lr, ip, r7
 8000f66:	ea6f 0e0e 	mvn.w	lr, lr
 8000f6a:	fa01 f807 	lsl.w	r8, r1, r7
 8000f6e:	ea0e 0505 	and.w	r5, lr, r5
 8000f72:	ea0e 0404 	and.w	r4, lr, r4
 8000f76:	fa02 f707 	lsl.w	r7, r2, r7
 8000f7a:	ea48 0505 	orr.w	r5, r8, r5
 8000f7e:	433c      	orrs	r4, r7
 8000f80:	3601      	adds	r6, #1
 8000f82:	2e10      	cmp	r6, #16
 8000f84:	d1e8      	bne.n	8000f58 <gpio_mode_setup+0xe>
 8000f86:	6005      	str	r5, [r0, #0]
 8000f88:	60c4      	str	r4, [r0, #12]
 8000f8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000f8e <gpio_set_af>:
 8000f8e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f90:	6a07      	ldr	r7, [r0, #32]
 8000f92:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8000f94:	2300      	movs	r3, #0
 8000f96:	f04f 0e0f 	mov.w	lr, #15
 8000f9a:	fa42 f403 	asr.w	r4, r2, r3
 8000f9e:	07e5      	lsls	r5, r4, #31
 8000fa0:	d507      	bpl.n	8000fb2 <gpio_set_af+0x24>
 8000fa2:	009d      	lsls	r5, r3, #2
 8000fa4:	fa0e f405 	lsl.w	r4, lr, r5
 8000fa8:	ea27 0704 	bic.w	r7, r7, r4
 8000fac:	fa01 f505 	lsl.w	r5, r1, r5
 8000fb0:	432f      	orrs	r7, r5
 8000fb2:	3301      	adds	r3, #1
 8000fb4:	2b08      	cmp	r3, #8
 8000fb6:	d1f0      	bne.n	8000f9a <gpio_set_af+0xc>
 8000fb8:	2300      	movs	r3, #0
 8000fba:	f04f 0e0f 	mov.w	lr, #15
 8000fbe:	f103 0408 	add.w	r4, r3, #8
 8000fc2:	fa42 f404 	asr.w	r4, r2, r4
 8000fc6:	07e4      	lsls	r4, r4, #31
 8000fc8:	d507      	bpl.n	8000fda <gpio_set_af+0x4c>
 8000fca:	009c      	lsls	r4, r3, #2
 8000fcc:	fa0e f504 	lsl.w	r5, lr, r4
 8000fd0:	ea26 0605 	bic.w	r6, r6, r5
 8000fd4:	fa01 f404 	lsl.w	r4, r1, r4
 8000fd8:	4326      	orrs	r6, r4
 8000fda:	3301      	adds	r3, #1
 8000fdc:	2b08      	cmp	r3, #8
 8000fde:	d1ee      	bne.n	8000fbe <gpio_set_af+0x30>
 8000fe0:	6207      	str	r7, [r0, #32]
 8000fe2:	6246      	str	r6, [r0, #36]	; 0x24
 8000fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08000fe8 <usart_set_baudrate>:
 8000fe8:	4a08      	ldr	r2, [pc, #32]	; (800100c <usart_set_baudrate+0x24>)
 8000fea:	4b09      	ldr	r3, [pc, #36]	; (8001010 <usart_set_baudrate+0x28>)
 8000fec:	b510      	push	{r4, lr}
 8000fee:	f420 6480 	bic.w	r4, r0, #1024	; 0x400
 8000ff2:	4294      	cmp	r4, r2
 8000ff4:	681b      	ldr	r3, [r3, #0]
 8000ff6:	bf04      	itt	eq
 8000ff8:	4b06      	ldreq	r3, [pc, #24]	; (8001014 <usart_set_baudrate+0x2c>)
 8000ffa:	681b      	ldreq	r3, [r3, #0]
 8000ffc:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8001000:	0049      	lsls	r1, r1, #1
 8001002:	fbb3 f3f1 	udiv	r3, r3, r1
 8001006:	6083      	str	r3, [r0, #8]
 8001008:	bd10      	pop	{r4, pc}
 800100a:	bf00      	nop
 800100c:	40011000 	.word	0x40011000
 8001010:	2000000c 	.word	0x2000000c
 8001014:	20000010 	.word	0x20000010

08001018 <usart_set_databits>:
 8001018:	68c3      	ldr	r3, [r0, #12]
 800101a:	2908      	cmp	r1, #8
 800101c:	bf0c      	ite	eq
 800101e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8001022:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8001026:	60c3      	str	r3, [r0, #12]
 8001028:	4770      	bx	lr

0800102a <usart_set_stopbits>:
 800102a:	6903      	ldr	r3, [r0, #16]
 800102c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8001030:	4319      	orrs	r1, r3
 8001032:	6101      	str	r1, [r0, #16]
 8001034:	4770      	bx	lr

08001036 <usart_set_parity>:
 8001036:	68c3      	ldr	r3, [r0, #12]
 8001038:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 800103c:	4319      	orrs	r1, r3
 800103e:	60c1      	str	r1, [r0, #12]
 8001040:	4770      	bx	lr

08001042 <usart_set_mode>:
 8001042:	68c3      	ldr	r3, [r0, #12]
 8001044:	f023 030c 	bic.w	r3, r3, #12
 8001048:	4319      	orrs	r1, r3
 800104a:	60c1      	str	r1, [r0, #12]
 800104c:	4770      	bx	lr

0800104e <usart_set_flow_control>:
 800104e:	6943      	ldr	r3, [r0, #20]
 8001050:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001054:	4319      	orrs	r1, r3
 8001056:	6141      	str	r1, [r0, #20]
 8001058:	4770      	bx	lr

0800105a <usart_enable>:
 800105a:	68c3      	ldr	r3, [r0, #12]
 800105c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001060:	60c3      	str	r3, [r0, #12]
 8001062:	4770      	bx	lr

08001064 <usart_send_blocking>:
 8001064:	b538      	push	{r3, r4, r5, lr}
 8001066:	4604      	mov	r4, r0
 8001068:	460d      	mov	r5, r1
 800106a:	f000 f80a 	bl	8001082 <usart_wait_send_ready>
 800106e:	4629      	mov	r1, r5
 8001070:	4620      	mov	r0, r4
 8001072:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001076:	f000 b800 	b.w	800107a <usart_send>

0800107a <usart_send>:
 800107a:	f3c1 0108 	ubfx	r1, r1, #0, #9
 800107e:	6041      	str	r1, [r0, #4]
 8001080:	4770      	bx	lr

08001082 <usart_wait_send_ready>:
 8001082:	6803      	ldr	r3, [r0, #0]
 8001084:	061b      	lsls	r3, r3, #24
 8001086:	d5fc      	bpl.n	8001082 <usart_wait_send_ready>
 8001088:	4770      	bx	lr
	...

0800108c <flash_set_ws>:
 800108c:	4a03      	ldr	r2, [pc, #12]	; (800109c <flash_set_ws+0x10>)
 800108e:	6813      	ldr	r3, [r2, #0]
 8001090:	f023 0307 	bic.w	r3, r3, #7
 8001094:	4318      	orrs	r0, r3
 8001096:	6010      	str	r0, [r2, #0]
 8001098:	4770      	bx	lr
 800109a:	bf00      	nop
 800109c:	40023c00 	.word	0x40023c00

080010a0 <rcc_periph_clock_enable>:
 80010a0:	0943      	lsrs	r3, r0, #5
 80010a2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80010a6:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 80010aa:	f000 021f 	and.w	r2, r0, #31
 80010ae:	6819      	ldr	r1, [r3, #0]
 80010b0:	2001      	movs	r0, #1
 80010b2:	4090      	lsls	r0, r2
 80010b4:	4308      	orrs	r0, r1
 80010b6:	6018      	str	r0, [r3, #0]
 80010b8:	4770      	bx	lr

080010ba <blocking_handler>:
 80010ba:	e7fe      	b.n	80010ba <blocking_handler>

080010bc <null_handler>:
 80010bc:	4770      	bx	lr
	...

080010c0 <reset_handler>:
 80010c0:	4c1a      	ldr	r4, [pc, #104]	; (800112c <reset_handler+0x6c>)
 80010c2:	491b      	ldr	r1, [pc, #108]	; (8001130 <reset_handler+0x70>)
 80010c4:	481b      	ldr	r0, [pc, #108]	; (8001134 <reset_handler+0x74>)
 80010c6:	2200      	movs	r2, #0
 80010c8:	1853      	adds	r3, r2, r1
 80010ca:	4283      	cmp	r3, r0
 80010cc:	d31a      	bcc.n	8001104 <reset_handler+0x44>
 80010ce:	4a1a      	ldr	r2, [pc, #104]	; (8001138 <reset_handler+0x78>)
 80010d0:	2100      	movs	r1, #0
 80010d2:	4293      	cmp	r3, r2
 80010d4:	d31a      	bcc.n	800110c <reset_handler+0x4c>
 80010d6:	4a19      	ldr	r2, [pc, #100]	; (800113c <reset_handler+0x7c>)
 80010d8:	4c19      	ldr	r4, [pc, #100]	; (8001140 <reset_handler+0x80>)
 80010da:	6813      	ldr	r3, [r2, #0]
 80010dc:	4d19      	ldr	r5, [pc, #100]	; (8001144 <reset_handler+0x84>)
 80010de:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80010e2:	6013      	str	r3, [r2, #0]
 80010e4:	6f53      	ldr	r3, [r2, #116]	; 0x74
 80010e6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80010ea:	6753      	str	r3, [r2, #116]	; 0x74
 80010ec:	42ac      	cmp	r4, r5
 80010ee:	d310      	bcc.n	8001112 <reset_handler+0x52>
 80010f0:	4c15      	ldr	r4, [pc, #84]	; (8001148 <reset_handler+0x88>)
 80010f2:	4d16      	ldr	r5, [pc, #88]	; (800114c <reset_handler+0x8c>)
 80010f4:	42ac      	cmp	r4, r5
 80010f6:	d310      	bcc.n	800111a <reset_handler+0x5a>
 80010f8:	f7ff f884 	bl	8000204 <main>
 80010fc:	4c14      	ldr	r4, [pc, #80]	; (8001150 <reset_handler+0x90>)
 80010fe:	4d15      	ldr	r5, [pc, #84]	; (8001154 <reset_handler+0x94>)
 8001100:	42ac      	cmp	r4, r5
 8001102:	d30e      	bcc.n	8001122 <reset_handler+0x62>
 8001104:	5913      	ldr	r3, [r2, r4]
 8001106:	5053      	str	r3, [r2, r1]
 8001108:	3204      	adds	r2, #4
 800110a:	e7dd      	b.n	80010c8 <reset_handler+0x8>
 800110c:	6019      	str	r1, [r3, #0]
 800110e:	3304      	adds	r3, #4
 8001110:	e7df      	b.n	80010d2 <reset_handler+0x12>
 8001112:	f854 3b04 	ldr.w	r3, [r4], #4
 8001116:	4798      	blx	r3
 8001118:	e7e8      	b.n	80010ec <reset_handler+0x2c>
 800111a:	f854 3b04 	ldr.w	r3, [r4], #4
 800111e:	4798      	blx	r3
 8001120:	e7e8      	b.n	80010f4 <reset_handler+0x34>
 8001122:	f854 3b04 	ldr.w	r3, [r4], #4
 8001126:	4798      	blx	r3
 8001128:	e7ea      	b.n	8001100 <reset_handler+0x40>
 800112a:	bf00      	nop
 800112c:	08001240 	.word	0x08001240
 8001130:	20000000 	.word	0x20000000
 8001134:	20000014 	.word	0x20000014
 8001138:	20001514 	.word	0x20001514
 800113c:	e000ed14 	.word	0xe000ed14
 8001140:	08001240 	.word	0x08001240
 8001144:	08001240 	.word	0x08001240
 8001148:	08001240 	.word	0x08001240
 800114c:	08001240 	.word	0x08001240
 8001150:	08001240 	.word	0x08001240
 8001154:	08001240 	.word	0x08001240

08001158 <pwr_set_vos_scale>:
 8001158:	b928      	cbnz	r0, 8001166 <pwr_set_vos_scale+0xe>
 800115a:	4a06      	ldr	r2, [pc, #24]	; (8001174 <pwr_set_vos_scale+0x1c>)
 800115c:	6813      	ldr	r3, [r2, #0]
 800115e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001162:	6013      	str	r3, [r2, #0]
 8001164:	4770      	bx	lr
 8001166:	2801      	cmp	r0, #1
 8001168:	d1fc      	bne.n	8001164 <pwr_set_vos_scale+0xc>
 800116a:	4a02      	ldr	r2, [pc, #8]	; (8001174 <pwr_set_vos_scale+0x1c>)
 800116c:	6813      	ldr	r3, [r2, #0]
 800116e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001172:	e7f6      	b.n	8001162 <pwr_set_vos_scale+0xa>
 8001174:	40007000 	.word	0x40007000

08001178 <memset>:
 8001178:	b470      	push	{r4, r5, r6}
 800117a:	0786      	lsls	r6, r0, #30
 800117c:	d046      	beq.n	800120c <memset+0x94>
 800117e:	1e54      	subs	r4, r2, #1
 8001180:	2a00      	cmp	r2, #0
 8001182:	d041      	beq.n	8001208 <memset+0x90>
 8001184:	b2ca      	uxtb	r2, r1
 8001186:	4603      	mov	r3, r0
 8001188:	e002      	b.n	8001190 <memset+0x18>
 800118a:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 800118e:	d33b      	bcc.n	8001208 <memset+0x90>
 8001190:	f803 2b01 	strb.w	r2, [r3], #1
 8001194:	079d      	lsls	r5, r3, #30
 8001196:	d1f8      	bne.n	800118a <memset+0x12>
 8001198:	2c03      	cmp	r4, #3
 800119a:	d92e      	bls.n	80011fa <memset+0x82>
 800119c:	b2cd      	uxtb	r5, r1
 800119e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80011a2:	2c0f      	cmp	r4, #15
 80011a4:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80011a8:	d919      	bls.n	80011de <memset+0x66>
 80011aa:	f103 0210 	add.w	r2, r3, #16
 80011ae:	4626      	mov	r6, r4
 80011b0:	3e10      	subs	r6, #16
 80011b2:	2e0f      	cmp	r6, #15
 80011b4:	f842 5c10 	str.w	r5, [r2, #-16]
 80011b8:	f842 5c0c 	str.w	r5, [r2, #-12]
 80011bc:	f842 5c08 	str.w	r5, [r2, #-8]
 80011c0:	f842 5c04 	str.w	r5, [r2, #-4]
 80011c4:	f102 0210 	add.w	r2, r2, #16
 80011c8:	d8f2      	bhi.n	80011b0 <memset+0x38>
 80011ca:	f1a4 0210 	sub.w	r2, r4, #16
 80011ce:	f022 020f 	bic.w	r2, r2, #15
 80011d2:	f004 040f 	and.w	r4, r4, #15
 80011d6:	3210      	adds	r2, #16
 80011d8:	2c03      	cmp	r4, #3
 80011da:	4413      	add	r3, r2
 80011dc:	d90d      	bls.n	80011fa <memset+0x82>
 80011de:	461e      	mov	r6, r3
 80011e0:	4622      	mov	r2, r4
 80011e2:	3a04      	subs	r2, #4
 80011e4:	2a03      	cmp	r2, #3
 80011e6:	f846 5b04 	str.w	r5, [r6], #4
 80011ea:	d8fa      	bhi.n	80011e2 <memset+0x6a>
 80011ec:	1f22      	subs	r2, r4, #4
 80011ee:	f022 0203 	bic.w	r2, r2, #3
 80011f2:	3204      	adds	r2, #4
 80011f4:	4413      	add	r3, r2
 80011f6:	f004 0403 	and.w	r4, r4, #3
 80011fa:	b12c      	cbz	r4, 8001208 <memset+0x90>
 80011fc:	b2c9      	uxtb	r1, r1
 80011fe:	441c      	add	r4, r3
 8001200:	f803 1b01 	strb.w	r1, [r3], #1
 8001204:	429c      	cmp	r4, r3
 8001206:	d1fb      	bne.n	8001200 <memset+0x88>
 8001208:	bc70      	pop	{r4, r5, r6}
 800120a:	4770      	bx	lr
 800120c:	4614      	mov	r4, r2
 800120e:	4603      	mov	r3, r0
 8001210:	e7c2      	b.n	8001198 <memset+0x20>
 8001212:	bf00      	nop
 8001214:	4664654c 	.word	0x4664654c
 8001218:	74616f6c 	.word	0x74616f6c
 800121c:	64654c00 	.word	0x64654c00
 8001220:	73616c46 	.word	0x73616c46
 8001224:	61550068 	.word	0x61550068
 8001228:	7472      	.short	0x7472
 800122a:	00          	.byte	0x00
 800122b:	48          	.byte	0x48
 800122c:	6f6c6c65 	.word	0x6f6c6c65
 8001230:	726f5720 	.word	0x726f5720
 8001234:	0a0d646c 	.word	0x0a0d646c
 8001238:	00          	.byte	0x00
 8001239:	49          	.byte	0x49
 800123a:	4c44      	.short	0x4c44
 800123c:	00000045 	.word	0x00000045
