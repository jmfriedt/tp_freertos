
output/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 80 00 20 99 14 00 08 95 14 00 08 93 14 00 08     ... ............
 8000010:	93 14 00 08 93 14 00 08 93 14 00 08 00 00 00 00     ................
	...
 800002c:	95 02 00 08 95 14 00 08 00 00 00 00 99 02 00 08     ................
 800003c:	9d 02 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800004c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800005c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800006c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800007c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800008c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800009c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 80000ac:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 80000bc:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 80000cc:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 80000dc:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 80000ec:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 80000fc:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800010c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800011c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800012c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800013c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800014c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800015c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800016c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800017c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800018c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................
 800019c:	93 14 00 08 93 14 00 08 93 14 00 08 93 14 00 08     ................

080001ac <task_tx>:
}

xQueueHandle qh = 0;
 
void task_tx(void* p)
{int myInt = 0;
 80001ac:	b507      	push	{r0, r1, r2, lr}
 80001ae:	ac02      	add	r4, sp, #8
 80001b0:	2300      	movs	r3, #0
 80001b2:	f844 3d04 	str.w	r3, [r4, #-4]!
  while(1)
    {myInt++;
     if(!xQueueSend(qh, &myInt, 500)) 
 80001b6:	4d0a      	ldr	r5, [pc, #40]	; (80001e0 <task_tx+0x34>)
        {uart_puts("Failed to send item to queue within 500ms");
 80001b8:	4e0a      	ldr	r6, [pc, #40]	; (80001e4 <task_tx+0x38>)
xQueueHandle qh = 0;
 
void task_tx(void* p)
{int myInt = 0;
  while(1)
    {myInt++;
 80001ba:	9b01      	ldr	r3, [sp, #4]
     if(!xQueueSend(qh, &myInt, 500)) 
 80001bc:	6828      	ldr	r0, [r5, #0]
xQueueHandle qh = 0;
 
void task_tx(void* p)
{int myInt = 0;
  while(1)
    {myInt++;
 80001be:	3301      	adds	r3, #1
 80001c0:	9301      	str	r3, [sp, #4]
     if(!xQueueSend(qh, &myInt, 500)) 
 80001c2:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80001c6:	2300      	movs	r3, #0
 80001c8:	4621      	mov	r1, r4
 80001ca:	f000 fe35 	bl	8000e38 <xQueueGenericSend>
 80001ce:	b910      	cbnz	r0, 80001d6 <task_tx+0x2a>
        {uart_puts("Failed to send item to queue within 500ms");
 80001d0:	4630      	mov	r0, r6
 80001d2:	f000 f8d1 	bl	8000378 <uart_puts>
        }
     vTaskDelay(1000);
 80001d6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80001da:	f000 fca1 	bl	8000b20 <vTaskDelay>
xQueueHandle qh = 0;
 
void task_tx(void* p)
{int myInt = 0;
  while(1)
    {myInt++;
 80001de:	e7ec      	b.n	80001ba <task_tx+0xe>
 80001e0:	20000014 	.word	0x20000014
 80001e4:	080016be 	.word	0x080016be

080001e8 <task_rx>:
     vTaskDelay(1000);
    }
}
 
void task_rx(void* p)
{char c[10];
 80001e8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 int myInt = 0;
 while(1)
    {if(!xQueueReceive(qh, &myInt, 1000)) 
 80001ea:	4e10      	ldr	r6, [pc, #64]	; (800022c <task_rx+0x44>)
       {uart_puts("Failed to receive item within 1000 ms");
       }
     else {c[0]='0'+myInt;c[1]=0;
           uart_puts("Received: ");uart_puts(c);uart_puts("\r\n");
 80001ec:	4d10      	ldr	r5, [pc, #64]	; (8000230 <task_rx+0x48>)
 80001ee:	4c11      	ldr	r4, [pc, #68]	; (8000234 <task_rx+0x4c>)
    }
}
 
void task_rx(void* p)
{char c[10];
 int myInt = 0;
 80001f0:	2300      	movs	r3, #0
 80001f2:	9300      	str	r3, [sp, #0]
 while(1)
    {if(!xQueueReceive(qh, &myInt, 1000)) 
 80001f4:	2300      	movs	r3, #0
 80001f6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80001fa:	4669      	mov	r1, sp
 80001fc:	6830      	ldr	r0, [r6, #0]
 80001fe:	f000 fe95 	bl	8000f2c <xQueueGenericReceive>
 8000202:	b918      	cbnz	r0, 800020c <task_rx+0x24>
       {uart_puts("Failed to receive item within 1000 ms");
 8000204:	480c      	ldr	r0, [pc, #48]	; (8000238 <task_rx+0x50>)
       }
     else {c[0]='0'+myInt;c[1]=0;
           uart_puts("Received: ");uart_puts(c);uart_puts("\r\n");
 8000206:	f000 f8b7 	bl	8000378 <uart_puts>
 800020a:	e7f3      	b.n	80001f4 <task_rx+0xc>
 int myInt = 0;
 while(1)
    {if(!xQueueReceive(qh, &myInt, 1000)) 
       {uart_puts("Failed to receive item within 1000 ms");
       }
     else {c[0]='0'+myInt;c[1]=0;
 800020c:	9b00      	ldr	r3, [sp, #0]
 800020e:	3330      	adds	r3, #48	; 0x30
 8000210:	f88d 3004 	strb.w	r3, [sp, #4]
           uart_puts("Received: ");uart_puts(c);uart_puts("\r\n");
 8000214:	4628      	mov	r0, r5
 int myInt = 0;
 while(1)
    {if(!xQueueReceive(qh, &myInt, 1000)) 
       {uart_puts("Failed to receive item within 1000 ms");
       }
     else {c[0]='0'+myInt;c[1]=0;
 8000216:	2300      	movs	r3, #0
 8000218:	f88d 3005 	strb.w	r3, [sp, #5]
           uart_puts("Received: ");uart_puts(c);uart_puts("\r\n");
 800021c:	f000 f8ac 	bl	8000378 <uart_puts>
 8000220:	a801      	add	r0, sp, #4
 8000222:	f000 f8a9 	bl	8000378 <uart_puts>
 8000226:	4620      	mov	r0, r4
 8000228:	e7ed      	b.n	8000206 <task_rx+0x1e>
 800022a:	bf00      	nop
 800022c:	20000014 	.word	0x20000014
 8000230:	080016b0 	.word	0x080016b0
 8000234:	080016bb 	.word	0x080016bb
 8000238:	0800168a 	.word	0x0800168a

0800023c <main>:
          }
    }
}

int main()
{Led_Init();
 800023c:	b507      	push	{r0, r1, r2, lr}
 800023e:	f000 f88b 	bl	8000358 <Led_Init>
 Usart1_Init();
 8000242:	f000 f849 	bl	80002d8 <Usart1_Init>

  qh = xQueueCreate(1, sizeof(int));
 8000246:	2200      	movs	r2, #0
 8000248:	2104      	movs	r1, #4
 800024a:	2001      	movs	r0, #1
 800024c:	f000 fddc 	bl	8000e08 <xQueueGenericCreate>
 8000250:	4b0b      	ldr	r3, [pc, #44]	; (8000280 <main+0x44>)
//  activer ces fonctions fait atteindre le timeout de transfert de donnees dans la queue
//    if (!(pdPASS == xTaskCreate( vLedsFloat, ( signed char * ) "LedFloat", 128, NULL, 2, NULL ))) goto hell;
//    if (!(pdPASS == xTaskCreate( vLedsFlash, ( signed char * ) "LedFlash", 128, NULL, 2, NULL ))) goto hell;
//    if (!(pdPASS == xTaskCreate( vPrintUart, ( signed char * ) "Uart",     128, NULL, 2, NULL ))) goto hell;

   xTaskCreate(task_tx, (signed char*)"t1", (128), 0, 2, 0);
 8000252:	490c      	ldr	r1, [pc, #48]	; (8000284 <main+0x48>)

int main()
{Led_Init();
 Usart1_Init();

  qh = xQueueCreate(1, sizeof(int));
 8000254:	6018      	str	r0, [r3, #0]
//  activer ces fonctions fait atteindre le timeout de transfert de donnees dans la queue
//    if (!(pdPASS == xTaskCreate( vLedsFloat, ( signed char * ) "LedFloat", 128, NULL, 2, NULL ))) goto hell;
//    if (!(pdPASS == xTaskCreate( vLedsFlash, ( signed char * ) "LedFlash", 128, NULL, 2, NULL ))) goto hell;
//    if (!(pdPASS == xTaskCreate( vPrintUart, ( signed char * ) "Uart",     128, NULL, 2, NULL ))) goto hell;

   xTaskCreate(task_tx, (signed char*)"t1", (128), 0, 2, 0);
 8000256:	2400      	movs	r4, #0
 8000258:	2502      	movs	r5, #2
 800025a:	4623      	mov	r3, r4
 800025c:	2280      	movs	r2, #128	; 0x80
 800025e:	9401      	str	r4, [sp, #4]
 8000260:	9500      	str	r5, [sp, #0]
 8000262:	4809      	ldr	r0, [pc, #36]	; (8000288 <main+0x4c>)
 8000264:	f000 fa5a 	bl	800071c <xTaskCreate>
   xTaskCreate(task_rx, (signed char*)"t2", (128), 0, 2, 0);
 8000268:	4623      	mov	r3, r4
 800026a:	2280      	movs	r2, #128	; 0x80
 800026c:	4907      	ldr	r1, [pc, #28]	; (800028c <main+0x50>)
 800026e:	9401      	str	r4, [sp, #4]
 8000270:	9500      	str	r5, [sp, #0]
 8000272:	4807      	ldr	r0, [pc, #28]	; (8000290 <main+0x54>)
 8000274:	f000 fa52 	bl	800071c <xTaskCreate>
   vTaskStartScheduler();
 8000278:	f000 fb28 	bl	80008cc <vTaskStartScheduler>
 800027c:	e7fe      	b.n	800027c <main+0x40>
 800027e:	bf00      	nop
 8000280:	20000014 	.word	0x20000014
 8000284:	08001684 	.word	0x08001684
 8000288:	080001ad 	.word	0x080001ad
 800028c:	08001687 	.word	0x08001687
 8000290:	080001e9 	.word	0x080001e9

08000294 <sv_call_handler>:
//
//The only significant change to make is to redirect the sv, pendsv and systick libopencm3 interrupt handlers to those used by FreeRTOS:

void sv_call_handler(void)
{
      vPortSVCHandler();
 8000294:	f000 b934 	b.w	8000500 <vPortSVCHandler>

08000298 <pend_sv_handler>:
}
 void pend_sv_handler(void)
{
      xPortPendSVHandler();
 8000298:	f000 b962 	b.w	8000560 <xPortPendSVHandler>

0800029c <sys_tick_handler>:
}
void sys_tick_handler(void)
{
      xPortSysTickHandler();
 800029c:	f000 b992 	b.w	80005c4 <xPortSysTickHandler>

080002a0 <clock_setup>:
int _write(int file, char *ptr, int len);
#endif


void clock_setup(void)
{
 80002a0:	b508      	push	{r3, lr}
 rcc_clock_setup_in_hse_8mhz_out_24mhz();  // STM32F100 discovery
#else
 rcc_clock_setup_in_hse_8mhz_out_72mhz();  // STM32F103
#endif
#else
rcc_clock_setup_hse_3v3(&rcc_hse_8mhz_3v3[RCC_CLOCK_3V3_168MHZ]); 
 80002a2:	480c      	ldr	r0, [pc, #48]	; (80002d4 <clock_setup+0x34>)
 80002a4:	f000 ffe8 	bl	8001278 <rcc_clock_setup_hse_3v3>
#endif
  rcc_periph_clock_enable(RCC_GPIOC); // Enable GPIOC clock
 80002a8:	f240 6002 	movw	r0, #1538	; 0x602
 80002ac:	f001 f8e4 	bl	8001478 <rcc_periph_clock_enable>
  rcc_periph_clock_enable(RCC_GPIOD); // Enable GPIOD clock for F4 (LEDs)
 80002b0:	f240 6003 	movw	r0, #1539	; 0x603
 80002b4:	f001 f8e0 	bl	8001478 <rcc_periph_clock_enable>
  rcc_periph_clock_enable(RCC_GPIOA); // Enable GPIOA clock
 80002b8:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 80002bc:	f001 f8dc 	bl	8001478 <rcc_periph_clock_enable>
  rcc_periph_clock_enable(RCC_USART1);
 80002c0:	f640 0084 	movw	r0, #2180	; 0x884
 80002c4:	f001 f8d8 	bl	8001478 <rcc_periph_clock_enable>
  rcc_periph_clock_enable(RCC_ADC1);  // exemple ADC
 80002c8:	f640 0088 	movw	r0, #2184	; 0x888
}
 80002cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#endif
  rcc_periph_clock_enable(RCC_GPIOC); // Enable GPIOC clock
  rcc_periph_clock_enable(RCC_GPIOD); // Enable GPIOD clock for F4 (LEDs)
  rcc_periph_clock_enable(RCC_GPIOA); // Enable GPIOA clock
  rcc_periph_clock_enable(RCC_USART1);
  rcc_periph_clock_enable(RCC_ADC1);  // exemple ADC
 80002d0:	f001 b8d2 	b.w	8001478 <rcc_periph_clock_enable>
 80002d4:	08001744 	.word	0x08001744

080002d8 <Usart1_Init>:
}


void Usart1_Init(void)
{ // Setup GPIO pin GPIO_USART1_TX/GPIO9 on GPIO port A for transmit. */
 80002d8:	b510      	push	{r4, lr}
  clock_setup();
#ifdef STM32F1
  gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
#else
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9);  //GPA9 : Tx send from STM32 to ext
 80002da:	4c1e      	ldr	r4, [pc, #120]	; (8000354 <Usart1_Init+0x7c>)
}


void Usart1_Init(void)
{ // Setup GPIO pin GPIO_USART1_TX/GPIO9 on GPIO port A for transmit. */
  clock_setup();
 80002dc:	f7ff ffe0 	bl	80002a0 <clock_setup>
#ifdef STM32F1
  gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
#else
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9);  //GPA9 : Tx send from STM32 to ext
 80002e0:	4620      	mov	r0, r4
 80002e2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80002e6:	2200      	movs	r2, #0
 80002e8:	2102      	movs	r1, #2
 80002ea:	f001 f81b 	bl	8001324 <gpio_mode_setup>
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO10); //GPD10: Rx recieve from ext to STM32
 80002ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80002f2:	4620      	mov	r0, r4
 80002f4:	2200      	movs	r2, #0
 80002f6:	2102      	movs	r1, #2
 80002f8:	f001 f814 	bl	8001324 <gpio_mode_setup>
  gpio_set_af (GPIOA, GPIO_AF7, GPIO9);
 80002fc:	4620      	mov	r0, r4
 80002fe:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000302:	2107      	movs	r1, #7
 8000304:	f001 f830 	bl	8001368 <gpio_set_af>
  gpio_set_af (GPIOA, GPIO_AF7, GPIO10);
 8000308:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800030c:	4620      	mov	r0, r4
 800030e:	2107      	movs	r1, #7
#endif
  usart_set_baudrate(USART1, 115200);
 8000310:	f5a4 4470 	sub.w	r4, r4, #61440	; 0xf000
      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
#else
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO9);  //GPA9 : Tx send from STM32 to ext
  gpio_mode_setup (GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO10); //GPD10: Rx recieve from ext to STM32
  gpio_set_af (GPIOA, GPIO_AF7, GPIO9);
  gpio_set_af (GPIOA, GPIO_AF7, GPIO10);
 8000314:	f001 f828 	bl	8001368 <gpio_set_af>
#endif
  usart_set_baudrate(USART1, 115200);
 8000318:	4620      	mov	r0, r4
 800031a:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 800031e:	f001 f84f 	bl	80013c0 <usart_set_baudrate>
  usart_set_databits(USART1, 8);
 8000322:	4620      	mov	r0, r4
 8000324:	2108      	movs	r1, #8
 8000326:	f001 f863 	bl	80013f0 <usart_set_databits>
  usart_set_stopbits(USART1, USART_STOPBITS_1);
 800032a:	4620      	mov	r0, r4
 800032c:	2100      	movs	r1, #0
 800032e:	f001 f868 	bl	8001402 <usart_set_stopbits>
  usart_set_mode(USART1, USART_MODE_TX);
 8000332:	4620      	mov	r0, r4
 8000334:	2108      	movs	r1, #8
 8000336:	f001 f870 	bl	800141a <usart_set_mode>
  usart_set_parity(USART1, USART_PARITY_NONE);
 800033a:	4620      	mov	r0, r4
 800033c:	2100      	movs	r1, #0
 800033e:	f001 f866 	bl	800140e <usart_set_parity>
  usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);
 8000342:	4620      	mov	r0, r4
 8000344:	2100      	movs	r1, #0
 8000346:	f001 f86e 	bl	8001426 <usart_set_flow_control>

  usart_enable(USART1);  // PA9 & PA10 for USART1
 800034a:	4620      	mov	r0, r4
}
 800034c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usart_set_stopbits(USART1, USART_STOPBITS_1);
  usart_set_mode(USART1, USART_MODE_TX);
  usart_set_parity(USART1, USART_PARITY_NONE);
  usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);

  usart_enable(USART1);  // PA9 & PA10 for USART1
 8000350:	f001 b86f 	b.w	8001432 <usart_enable>
 8000354:	40020000 	.word	0x40020000

08000358 <Led_Init>:
void Led_Init(void)
{
#ifdef STM32F1
 gpio_set_mode(GPIOC,GPIO_MODE_OUTPUT_2_MHZ,GPIO_CNF_OUTPUT_PUSHPULL,GPIO8|GPIO9|GPIO1|GPIO2);
#else
 gpio_mode_setup(GPIOD, GPIO_MODE_OUTPUT,GPIO_PUPD_NONE, GPIO12|GPIO13|GPIO14|GPIO15); 
 8000358:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 800035c:	2200      	movs	r2, #0
 800035e:	2101      	movs	r1, #1
 8000360:	4801      	ldr	r0, [pc, #4]	; (8000368 <Led_Init+0x10>)
 8000362:	f000 bfdf 	b.w	8001324 <gpio_mode_setup>
 8000366:	bf00      	nop
 8000368:	40020c00 	.word	0x40020c00

0800036c <uart_putc>:
  errno = EIO;
  return -1;
}
#endif

void uart_putc(char c) {usart_send_blocking(USART1, c);} // USART1: send byte
 800036c:	4601      	mov	r1, r0
 800036e:	4801      	ldr	r0, [pc, #4]	; (8000374 <uart_putc+0x8>)
 8000370:	f001 b864 	b.w	800143c <usart_send_blocking>
 8000374:	40011000 	.word	0x40011000

08000378 <uart_puts>:

/* Writes a zero teminated string over the serial line*/
void uart_puts(char *c) {while(*c!=0) uart_putc(*(c++));}
 8000378:	b510      	push	{r4, lr}
 800037a:	1e44      	subs	r4, r0, #1
 800037c:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8000380:	b900      	cbnz	r0, 8000384 <uart_puts+0xc>
 8000382:	bd10      	pop	{r4, pc}
 8000384:	f7ff fff2 	bl	800036c <uart_putc>
 8000388:	e7f8      	b.n	800037c <uart_puts+0x4>
	...

0800038c <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800038c:	b570      	push	{r4, r5, r6, lr}
 800038e:	4604      	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 8000390:	f000 facc 	bl	800092c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 8000394:	4825      	ldr	r0, [pc, #148]	; (800042c <pvPortMalloc+0xa0>)
 8000396:	6801      	ldr	r1, [r0, #0]
 8000398:	b971      	cbnz	r1, 80003b8 <pvPortMalloc+0x2c>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 800039a:	4b25      	ldr	r3, [pc, #148]	; (8000430 <pvPortMalloc+0xa4>)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800039c:	4a25      	ldr	r2, [pc, #148]	; (8000434 <pvPortMalloc+0xa8>)
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 800039e:	f023 0307 	bic.w	r3, r3, #7

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80003a2:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80003a4:	6051      	str	r1, [r2, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 80003a6:	4a24      	ldr	r2, [pc, #144]	; (8000438 <pvPortMalloc+0xac>)
 80003a8:	f241 35f8 	movw	r5, #5112	; 0x13f8
	xEnd.pxNextFreeBlock = NULL;
 80003ac:	e882 0022 	stmia.w	r2, {r1, r5}

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 80003b0:	e883 0024 	stmia.w	r3, {r2, r5}
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 80003b4:	2301      	movs	r3, #1
 80003b6:	6003      	str	r3, [r0, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 80003b8:	b12c      	cbz	r4, 80003c6 <pvPortMalloc+0x3a>
		{
			xWantedSize += heapSTRUCT_SIZE;
 80003ba:	3408      	adds	r4, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 80003bc:	0763      	lsls	r3, r4, #29
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 80003be:	bf1c      	itt	ne
 80003c0:	f024 0407 	bicne.w	r4, r4, #7
 80003c4:	3408      	addne	r4, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 80003c6:	1e62      	subs	r2, r4, #1
 80003c8:	f241 33f6 	movw	r3, #5110	; 0x13f6
 80003cc:	429a      	cmp	r2, r3
 80003ce:	d807      	bhi.n	80003e0 <pvPortMalloc+0x54>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 80003d0:	4a18      	ldr	r2, [pc, #96]	; (8000434 <pvPortMalloc+0xa8>)
 80003d2:	6813      	ldr	r3, [r2, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80003d4:	6859      	ldr	r1, [r3, #4]
 80003d6:	428c      	cmp	r4, r1
 80003d8:	d804      	bhi.n	80003e4 <pvPortMalloc+0x58>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 80003da:	4817      	ldr	r0, [pc, #92]	; (8000438 <pvPortMalloc+0xac>)
 80003dc:	4283      	cmp	r3, r0
 80003de:	d107      	bne.n	80003f0 <pvPortMalloc+0x64>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 80003e0:	2500      	movs	r5, #0
 80003e2:	e01d      	b.n	8000420 <pvPortMalloc+0x94>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80003e4:	6818      	ldr	r0, [r3, #0]
 80003e6:	2800      	cmp	r0, #0
 80003e8:	d0f7      	beq.n	80003da <pvPortMalloc+0x4e>
 80003ea:	461a      	mov	r2, r3
 80003ec:	4603      	mov	r3, r0
 80003ee:	e7f1      	b.n	80003d4 <pvPortMalloc+0x48>
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80003f0:	6818      	ldr	r0, [r3, #0]
			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 80003f2:	6815      	ldr	r5, [r2, #0]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80003f4:	6010      	str	r0, [r2, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80003f6:	1b0a      	subs	r2, r1, r4
 80003f8:	2a10      	cmp	r2, #16
			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 80003fa:	f105 0508 	add.w	r5, r5, #8
				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80003fe:	d90a      	bls.n	8000416 <pvPortMalloc+0x8a>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8000400:	1919      	adds	r1, r3, r4

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8000402:	604a      	str	r2, [r1, #4]
					pxBlock->xBlockSize = xWantedSize;
 8000404:	605c      	str	r4, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8000406:	684e      	ldr	r6, [r1, #4]
 8000408:	4a0a      	ldr	r2, [pc, #40]	; (8000434 <pvPortMalloc+0xa8>)
 800040a:	6810      	ldr	r0, [r2, #0]
 800040c:	6844      	ldr	r4, [r0, #4]
 800040e:	42a6      	cmp	r6, r4
 8000410:	d80a      	bhi.n	8000428 <pvPortMalloc+0x9c>
 8000412:	6008      	str	r0, [r1, #0]
 8000414:	6011      	str	r1, [r2, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 8000416:	4909      	ldr	r1, [pc, #36]	; (800043c <pvPortMalloc+0xb0>)
 8000418:	685b      	ldr	r3, [r3, #4]
 800041a:	680a      	ldr	r2, [r1, #0]
 800041c:	1ad2      	subs	r2, r2, r3
 800041e:	600a      	str	r2, [r1, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8000420:	f000 fb12 	bl	8000a48 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8000424:	4628      	mov	r0, r5
 8000426:	bd70      	pop	{r4, r5, r6, pc}
 8000428:	4602      	mov	r2, r0
 800042a:	e7ee      	b.n	800040a <pvPortMalloc+0x7e>
 800042c:	20001420 	.word	0x20001420
 8000430:	20000020 	.word	0x20000020
 8000434:	20001424 	.word	0x20001424
 8000438:	20001418 	.word	0x20001418
 800043c:	20000000 	.word	0x20000000

08000440 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8000440:	b538      	push	{r3, r4, r5, lr}
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 8000442:	4604      	mov	r4, r0
 8000444:	b1b8      	cbz	r0, 8000476 <vPortFree+0x36>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 8000446:	f1a0 0508 	sub.w	r5, r0, #8

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 800044a:	f000 fa6f 	bl	800092c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800044e:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8000452:	4a09      	ldr	r2, [pc, #36]	; (8000478 <vPortFree+0x38>)
 8000454:	6811      	ldr	r1, [r2, #0]
 8000456:	684b      	ldr	r3, [r1, #4]
 8000458:	4298      	cmp	r0, r3
 800045a:	d80a      	bhi.n	8000472 <vPortFree+0x32>
 800045c:	f844 1c08 	str.w	r1, [r4, #-8]
 8000460:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 8000462:	4a06      	ldr	r2, [pc, #24]	; (800047c <vPortFree+0x3c>)
 8000464:	6813      	ldr	r3, [r2, #0]
 8000466:	4403      	add	r3, r0
 8000468:	6013      	str	r3, [r2, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
 800046a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 800046e:	f000 baeb 	b.w	8000a48 <xTaskResumeAll>
 8000472:	460a      	mov	r2, r1
 8000474:	e7ee      	b.n	8000454 <vPortFree+0x14>
 8000476:	bd38      	pop	{r3, r4, r5, pc}
 8000478:	20001424 	.word	0x20001424
 800047c:	20000000 	.word	0x20000000

08000480 <prvTaskExitError>:

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8000480:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8000484:	f383 8811 	msr	BASEPRI, r3
 8000488:	f3bf 8f6f 	isb	sy
 800048c:	f3bf 8f4f 	dsb	sy
 8000490:	e7fe      	b.n	8000490 <prvTaskExitError+0x10>
	...

08000494 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8000494:	4806      	ldr	r0, [pc, #24]	; (80004b0 <prvPortStartFirstTask+0x1c>)
 8000496:	6800      	ldr	r0, [r0, #0]
 8000498:	6800      	ldr	r0, [r0, #0]
 800049a:	f380 8808 	msr	MSP, r0
 800049e:	b662      	cpsie	i
 80004a0:	b661      	cpsie	f
 80004a2:	f3bf 8f4f 	dsb	sy
 80004a6:	f3bf 8f6f 	isb	sy
 80004aa:	df00      	svc	0
 80004ac:	bf00      	nop
 80004ae:	0000      	.short	0x0000
 80004b0:	e000ed08 	.word	0xe000ed08

080004b4 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80004b4:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80004c4 <vPortEnableVFP+0x10>
 80004b8:	6801      	ldr	r1, [r0, #0]
 80004ba:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004be:	6001      	str	r1, [r0, #0]
 80004c0:	4770      	bx	lr
 80004c2:	0000      	.short	0x0000
 80004c4:	e000ed88 	.word	0xe000ed88

080004c8 <pxPortInitialiseStack>:

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80004c8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80004cc:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80004d0:	4b07      	ldr	r3, [pc, #28]	; (80004f0 <pxPortInitialiseStack+0x28>)
 80004d2:	f840 3c0c 	str.w	r3, [r0, #-12]
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80004d6:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80004da:	f06f 0302 	mvn.w	r3, #2
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80004de:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80004e2:	f840 2c20 	str.w	r2, [r0, #-32]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80004e6:	f840 3c24 	str.w	r3, [r0, #-36]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 80004ea:	3844      	subs	r0, #68	; 0x44
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop
 80004f0:	08000481 	.word	0x08000481
	...

08000500 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000500:	4b07      	ldr	r3, [pc, #28]	; (8000520 <pxCurrentTCBConst2>)
 8000502:	6819      	ldr	r1, [r3, #0]
 8000504:	6808      	ldr	r0, [r1, #0]
 8000506:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800050a:	f380 8809 	msr	PSP, r0
 800050e:	f3bf 8f6f 	isb	sy
 8000512:	f04f 0000 	mov.w	r0, #0
 8000516:	f380 8811 	msr	BASEPRI, r0
 800051a:	4770      	bx	lr
 800051c:	f3af 8000 	nop.w

08000520 <pxCurrentTCBConst2>:
 8000520:	2000142c 	.word	0x2000142c

08000524 <vPortEnterCritical>:
 8000524:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8000528:	f383 8811 	msr	BASEPRI, r3
 800052c:	f3bf 8f6f 	isb	sy
 8000530:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8000534:	4a02      	ldr	r2, [pc, #8]	; (8000540 <vPortEnterCritical+0x1c>)
 8000536:	6813      	ldr	r3, [r2, #0]
 8000538:	3301      	adds	r3, #1
 800053a:	6013      	str	r3, [r2, #0]
 800053c:	4770      	bx	lr
 800053e:	bf00      	nop
 8000540:	20000004 	.word	0x20000004

08000544 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
 8000544:	4a03      	ldr	r2, [pc, #12]	; (8000554 <vPortExitCritical+0x10>)
 8000546:	6813      	ldr	r3, [r2, #0]
 8000548:	3b01      	subs	r3, #1
 800054a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800054c:	b90b      	cbnz	r3, 8000552 <vPortExitCritical+0xe>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800054e:	f383 8811 	msr	BASEPRI, r3
 8000552:	4770      	bx	lr
 8000554:	20000004 	.word	0x20000004
	...

08000560 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8000560:	f3ef 8009 	mrs	r0, PSP
 8000564:	f3bf 8f6f 	isb	sy
 8000568:	4b15      	ldr	r3, [pc, #84]	; (80005c0 <pxCurrentTCBConst>)
 800056a:	681a      	ldr	r2, [r3, #0]
 800056c:	f01e 0f10 	tst.w	lr, #16
 8000570:	bf08      	it	eq
 8000572:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8000576:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800057a:	6010      	str	r0, [r2, #0]
 800057c:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8000580:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8000584:	f380 8811 	msr	BASEPRI, r0
 8000588:	f3bf 8f4f 	dsb	sy
 800058c:	f3bf 8f6f 	isb	sy
 8000590:	f000 fade 	bl	8000b50 <vTaskSwitchContext>
 8000594:	f04f 0000 	mov.w	r0, #0
 8000598:	f380 8811 	msr	BASEPRI, r0
 800059c:	bc08      	pop	{r3}
 800059e:	6819      	ldr	r1, [r3, #0]
 80005a0:	6808      	ldr	r0, [r1, #0]
 80005a2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80005a6:	f01e 0f10 	tst.w	lr, #16
 80005aa:	bf08      	it	eq
 80005ac:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80005b0:	f380 8809 	msr	PSP, r0
 80005b4:	f3bf 8f6f 	isb	sy
 80005b8:	4770      	bx	lr
 80005ba:	bf00      	nop
 80005bc:	f3af 8000 	nop.w

080005c0 <pxCurrentTCBConst>:
 80005c0:	2000142c 	.word	0x2000142c

080005c4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80005c4:	b508      	push	{r3, lr}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80005c6:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 80005ca:	f383 8811 	msr	BASEPRI, r3
 80005ce:	f3bf 8f6f 	isb	sy
 80005d2:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80005d6:	f000 f9b1 	bl	800093c <xTaskIncrementTick>
 80005da:	b118      	cbz	r0, 80005e4 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80005dc:	4b03      	ldr	r3, [pc, #12]	; (80005ec <xPortSysTickHandler+0x28>)
 80005de:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80005e2:	601a      	str	r2, [r3, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80005e4:	2300      	movs	r3, #0
 80005e6:	f383 8811 	msr	BASEPRI, r3
 80005ea:	bd08      	pop	{r3, pc}
 80005ec:	e000ed04 	.word	0xe000ed04

080005f0 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80005f0:	4b03      	ldr	r3, [pc, #12]	; (8000600 <vPortSetupTimerInterrupt+0x10>)
 80005f2:	4a04      	ldr	r2, [pc, #16]	; (8000604 <vPortSetupTimerInterrupt+0x14>)
 80005f4:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 80005f6:	2207      	movs	r2, #7
 80005f8:	f843 2c04 	str.w	r2, [r3, #-4]
 80005fc:	4770      	bx	lr
 80005fe:	bf00      	nop
 8000600:	e000e014 	.word	0xe000e014
 8000604:	0001193f 	.word	0x0001193f

08000608 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8000608:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800060a:	4b0c      	ldr	r3, [pc, #48]	; (800063c <xPortStartScheduler+0x34>)
 800060c:	681a      	ldr	r2, [r3, #0]
 800060e:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8000612:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8000614:	681a      	ldr	r2, [r3, #0]
 8000616:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 800061a:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800061c:	f7ff ffe8 	bl	80005f0 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000620:	4b07      	ldr	r3, [pc, #28]	; (8000640 <xPortStartScheduler+0x38>)
 8000622:	2200      	movs	r2, #0
 8000624:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8000626:	f7ff ff45 	bl	80004b4 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800062a:	4a06      	ldr	r2, [pc, #24]	; (8000644 <xPortStartScheduler+0x3c>)
 800062c:	6813      	ldr	r3, [r2, #0]
 800062e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8000632:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8000634:	f7ff ff2e 	bl	8000494 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8000638:	f7ff ff22 	bl	8000480 <prvTaskExitError>
 800063c:	e000ed20 	.word	0xe000ed20
 8000640:	20000004 	.word	0x20000004
 8000644:	e000ef34 	.word	0xe000ef34

08000648 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8000648:	4906      	ldr	r1, [pc, #24]	; (8000664 <prvIdleTask+0x1c>)
			{
				taskYIELD();
 800064a:	4b07      	ldr	r3, [pc, #28]	; (8000668 <prvIdleTask+0x20>)
 800064c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8000650:	6808      	ldr	r0, [r1, #0]
 8000652:	2801      	cmp	r0, #1
 8000654:	d9fd      	bls.n	8000652 <prvIdleTask+0xa>
			{
				taskYIELD();
 8000656:	601a      	str	r2, [r3, #0]
 8000658:	f3bf 8f4f 	dsb	sy
 800065c:	f3bf 8f6f 	isb	sy
 8000660:	e7f6      	b.n	8000650 <prvIdleTask+0x8>
 8000662:	bf00      	nop
 8000664:	20001438 	.word	0x20001438
 8000668:	e000ed04 	.word	0xe000ed04

0800066c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800066c:	4a06      	ldr	r2, [pc, #24]	; (8000688 <prvResetNextTaskUnblockTime+0x1c>)
 800066e:	6813      	ldr	r3, [r2, #0]
 8000670:	6819      	ldr	r1, [r3, #0]
 8000672:	4b06      	ldr	r3, [pc, #24]	; (800068c <prvResetNextTaskUnblockTime+0x20>)
 8000674:	b919      	cbnz	r1, 800067e <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8000676:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800067a:	601a      	str	r2, [r3, #0]
 800067c:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800067e:	6812      	ldr	r2, [r2, #0]
 8000680:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8000682:	68d2      	ldr	r2, [r2, #12]
 8000684:	6852      	ldr	r2, [r2, #4]
 8000686:	e7f8      	b.n	800067a <prvResetNextTaskUnblockTime+0xe>
 8000688:	20001430 	.word	0x20001430
 800068c:	200014dc 	.word	0x200014dc

08000690 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8000690:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8000692:	4b1b      	ldr	r3, [pc, #108]	; (8000700 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000694:	4e1b      	ldr	r6, [pc, #108]	; (8000704 <prvAddCurrentTaskToDelayedList+0x74>)


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8000696:	681d      	ldr	r5, [r3, #0]
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8000698:	4604      	mov	r4, r0
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800069a:	6830      	ldr	r0, [r6, #0]
 800069c:	3004      	adds	r0, #4
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800069e:	460f      	mov	r7, r1
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80006a0:	f000 fd01 	bl	80010a6 <uxListRemove>
 80006a4:	4633      	mov	r3, r6
 80006a6:	b940      	cbnz	r0, 80006ba <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80006a8:	6831      	ldr	r1, [r6, #0]
 80006aa:	4e17      	ldr	r6, [pc, #92]	; (8000708 <prvAddCurrentTaskToDelayedList+0x78>)
 80006ac:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80006ae:	6832      	ldr	r2, [r6, #0]
 80006b0:	2001      	movs	r0, #1
 80006b2:	4088      	lsls	r0, r1
 80006b4:	ea22 0200 	bic.w	r2, r2, r0
 80006b8:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80006ba:	1c62      	adds	r2, r4, #1
 80006bc:	d107      	bne.n	80006ce <prvAddCurrentTaskToDelayedList+0x3e>
 80006be:	b137      	cbz	r7, 80006ce <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80006c0:	6819      	ldr	r1, [r3, #0]
 80006c2:	4812      	ldr	r0, [pc, #72]	; (800070c <prvAddCurrentTaskToDelayedList+0x7c>)
 80006c4:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80006c6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80006ca:	f000 bcc9 	b.w	8001060 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 80006ce:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80006d0:	681a      	ldr	r2, [r3, #0]

			if( xTimeToWake < xConstTickCount )
 80006d2:	42a5      	cmp	r5, r4
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80006d4:	6054      	str	r4, [r2, #4]

			if( xTimeToWake < xConstTickCount )
 80006d6:	d907      	bls.n	80006e8 <prvAddCurrentTaskToDelayedList+0x58>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80006d8:	4a0d      	ldr	r2, [pc, #52]	; (8000710 <prvAddCurrentTaskToDelayedList+0x80>)
 80006da:	6810      	ldr	r0, [r2, #0]
 80006dc:	6819      	ldr	r1, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80006de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80006e2:	3104      	adds	r1, #4
 80006e4:	f000 bcc8 	b.w	8001078 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80006e8:	4a0a      	ldr	r2, [pc, #40]	; (8000714 <prvAddCurrentTaskToDelayedList+0x84>)
 80006ea:	6810      	ldr	r0, [r2, #0]
 80006ec:	6819      	ldr	r1, [r3, #0]
 80006ee:	3104      	adds	r1, #4
 80006f0:	f000 fcc2 	bl	8001078 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 80006f4:	4b08      	ldr	r3, [pc, #32]	; (8000718 <prvAddCurrentTaskToDelayedList+0x88>)
 80006f6:	681a      	ldr	r2, [r3, #0]
 80006f8:	4294      	cmp	r4, r2
				{
					xNextTaskUnblockTime = xTimeToWake;
 80006fa:	bf38      	it	cc
 80006fc:	601c      	strcc	r4, [r3, #0]
 80006fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000700:	20001510 	.word	0x20001510
 8000704:	2000142c 	.word	0x2000142c
 8000708:	200014ac 	.word	0x200014ac
 800070c:	200014fc 	.word	0x200014fc
 8000710:	20001434 	.word	0x20001434
 8000714:	20001430 	.word	0x20001430
 8000718:	200014dc 	.word	0x200014dc

0800071c <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 800071c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000720:	ea4f 0a82 	mov.w	sl, r2, lsl #2
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8000724:	4680      	mov	r8, r0
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000726:	4650      	mov	r0, sl
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8000728:	460f      	mov	r7, r1
 800072a:	4699      	mov	r9, r3
 800072c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800072e:	f7ff fe2d 	bl	800038c <pvPortMalloc>

			if( pxStack != NULL )
 8000732:	4605      	mov	r5, r0
 8000734:	2800      	cmp	r0, #0
 8000736:	f000 8099 	beq.w	800086c <xTaskCreate+0x150>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800073a:	204c      	movs	r0, #76	; 0x4c
 800073c:	f7ff fe26 	bl	800038c <pvPortMalloc>

				if( pxNewTCB != NULL )
 8000740:	4604      	mov	r4, r0
 8000742:	2800      	cmp	r0, #0
 8000744:	f000 808f 	beq.w	8000866 <xTaskCreate+0x14a>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8000748:	f1aa 0a04 	sub.w	sl, sl, #4
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */

				if( pxNewTCB != NULL )
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 800074c:	6305      	str	r5, [r0, #48]	; 0x30
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800074e:	4455      	add	r5, sl
 8000750:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8000752:	f025 0a07 	bic.w	sl, r5, #7
 8000756:	f100 0234 	add.w	r2, r0, #52	; 0x34
 800075a:	370f      	adds	r7, #15
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800075c:	7859      	ldrb	r1, [r3, #1]
 800075e:	f802 1b01 	strb.w	r1, [r2], #1

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8000762:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8000766:	b109      	cbz	r1, 800076c <xTaskCreate+0x50>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8000768:	42bb      	cmp	r3, r7
 800076a:	d1f7      	bne.n	800075c <xTaskCreate+0x40>
 800076c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800076e:	2d04      	cmp	r5, #4
 8000770:	bf28      	it	cs
 8000772:	2504      	movcs	r5, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8000774:	f04f 0b00 	mov.w	fp, #0
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8000778:	1d27      	adds	r7, r4, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 800077a:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800077c:	4638      	mov	r0, r7
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800077e:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8000782:	f000 fc6a 	bl	800105a <vListInitialiseItem>
	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000786:	f1c5 0505 	rsb	r5, r5, #5
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800078a:	f104 0018 	add.w	r0, r4, #24
 800078e:	f000 fc64 	bl	800105a <vListInitialiseItem>
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 8000792:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8000796:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000798:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800079a:	6264      	str	r4, [r4, #36]	; 0x24
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800079c:	f884 b048 	strb.w	fp, [r4, #72]	; 0x48
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80007a0:	464a      	mov	r2, r9
 80007a2:	4641      	mov	r1, r8
 80007a4:	4650      	mov	r0, sl
 80007a6:	f7ff fe8f 	bl	80004c8 <pxPortInitialiseStack>
 80007aa:	6020      	str	r0, [r4, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 80007ac:	b106      	cbz	r6, 80007b0 <xTaskCreate+0x94>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80007ae:	6034      	str	r4, [r6, #0]

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 80007b0:	f7ff feb8 	bl	8000524 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 80007b4:	4b34      	ldr	r3, [pc, #208]	; (8000888 <xTaskCreate+0x16c>)
		if( pxCurrentTCB == NULL )
 80007b6:	4e35      	ldr	r6, [pc, #212]	; (800088c <xTaskCreate+0x170>)
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
	{
		uxCurrentNumberOfTasks++;
 80007b8:	681a      	ldr	r2, [r3, #0]
 80007ba:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80008c4 <xTaskCreate+0x1a8>
 80007be:	3201      	adds	r2, #1
 80007c0:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 80007c2:	6832      	ldr	r2, [r6, #0]
 80007c4:	2a00      	cmp	r2, #0
 80007c6:	d154      	bne.n	8000872 <xTaskCreate+0x156>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 80007c8:	6034      	str	r4, [r6, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80007ca:	681b      	ldr	r3, [r3, #0]
 80007cc:	2b01      	cmp	r3, #1
 80007ce:	d122      	bne.n	8000816 <xTaskCreate+0xfa>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80007d0:	482f      	ldr	r0, [pc, #188]	; (8000890 <xTaskCreate+0x174>)
	}

	vListInitialise( &xDelayedTaskList1 );
 80007d2:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 80008c8 <xTaskCreate+0x1ac>
	vListInitialise( &xDelayedTaskList2 );
 80007d6:	4d2f      	ldr	r5, [pc, #188]	; (8000894 <xTaskCreate+0x178>)
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80007d8:	f000 fc34 	bl	8001044 <vListInitialise>
 80007dc:	482e      	ldr	r0, [pc, #184]	; (8000898 <xTaskCreate+0x17c>)
 80007de:	f000 fc31 	bl	8001044 <vListInitialise>
 80007e2:	482e      	ldr	r0, [pc, #184]	; (800089c <xTaskCreate+0x180>)
 80007e4:	f000 fc2e 	bl	8001044 <vListInitialise>
 80007e8:	482d      	ldr	r0, [pc, #180]	; (80008a0 <xTaskCreate+0x184>)
 80007ea:	f000 fc2b 	bl	8001044 <vListInitialise>
 80007ee:	482d      	ldr	r0, [pc, #180]	; (80008a4 <xTaskCreate+0x188>)
 80007f0:	f000 fc28 	bl	8001044 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 80007f4:	4648      	mov	r0, r9
 80007f6:	f000 fc25 	bl	8001044 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80007fa:	4628      	mov	r0, r5
 80007fc:	f000 fc22 	bl	8001044 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8000800:	4829      	ldr	r0, [pc, #164]	; (80008a8 <xTaskCreate+0x18c>)
 8000802:	f000 fc1f 	bl	8001044 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8000806:	4829      	ldr	r0, [pc, #164]	; (80008ac <xTaskCreate+0x190>)
 8000808:	f000 fc1c 	bl	8001044 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800080c:	4b28      	ldr	r3, [pc, #160]	; (80008b0 <xTaskCreate+0x194>)
 800080e:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000812:	4b28      	ldr	r3, [pc, #160]	; (80008b4 <xTaskCreate+0x198>)
 8000814:	601d      	str	r5, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 8000816:	4a28      	ldr	r2, [pc, #160]	; (80008b8 <xTaskCreate+0x19c>)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8000818:	4928      	ldr	r1, [pc, #160]	; (80008bc <xTaskCreate+0x1a0>)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800081a:	6813      	ldr	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 800081c:	6808      	ldr	r0, [r1, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800081e:	3301      	adds	r3, #1
 8000820:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8000822:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000824:	2501      	movs	r5, #1
 8000826:	fa05 f302 	lsl.w	r3, r5, r2
 800082a:	4303      	orrs	r3, r0
 800082c:	600b      	str	r3, [r1, #0]
 800082e:	4b18      	ldr	r3, [pc, #96]	; (8000890 <xTaskCreate+0x174>)
 8000830:	2014      	movs	r0, #20
 8000832:	fb00 3002 	mla	r0, r0, r2, r3
 8000836:	4639      	mov	r1, r7
 8000838:	f000 fc12 	bl	8001060 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 800083c:	f7ff fe82 	bl	8000544 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8000840:	f8d8 3000 	ldr.w	r3, [r8]
 8000844:	b163      	cbz	r3, 8000860 <xTaskCreate+0x144>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8000846:	6833      	ldr	r3, [r6, #0]
 8000848:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800084a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800084c:	429a      	cmp	r2, r3
 800084e:	d207      	bcs.n	8000860 <xTaskCreate+0x144>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8000850:	4b1b      	ldr	r3, [pc, #108]	; (80008c0 <xTaskCreate+0x1a4>)
 8000852:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000856:	601a      	str	r2, [r3, #0]
 8000858:	f3bf 8f4f 	dsb	sy
 800085c:	f3bf 8f6f 	isb	sy
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
 8000860:	4628      	mov	r0, r5
 8000862:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 8000866:	4628      	mov	r0, r5
 8000868:	f7ff fdea 	bl	8000440 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800086c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8000870:	e7f6      	b.n	8000860 <xTaskCreate+0x144>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 8000872:	f8d8 3000 	ldr.w	r3, [r8]
 8000876:	2b00      	cmp	r3, #0
 8000878:	d1cd      	bne.n	8000816 <xTaskCreate+0xfa>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800087a:	6833      	ldr	r3, [r6, #0]
 800087c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800087e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000880:	429a      	cmp	r2, r3
				{
					pxCurrentTCB = pxNewTCB;
 8000882:	bf98      	it	ls
 8000884:	6034      	strls	r4, [r6, #0]
 8000886:	e7c6      	b.n	8000816 <xTaskCreate+0xfa>
 8000888:	2000149c 	.word	0x2000149c
 800088c:	2000142c 	.word	0x2000142c
 8000890:	20001438 	.word	0x20001438
 8000894:	200014c4 	.word	0x200014c4
 8000898:	2000144c 	.word	0x2000144c
 800089c:	20001460 	.word	0x20001460
 80008a0:	20001474 	.word	0x20001474
 80008a4:	20001488 	.word	0x20001488
 80008a8:	200014e4 	.word	0x200014e4
 80008ac:	200014fc 	.word	0x200014fc
 80008b0:	20001430 	.word	0x20001430
 80008b4:	20001434 	.word	0x20001434
 80008b8:	200014a8 	.word	0x200014a8
 80008bc:	200014ac 	.word	0x200014ac
 80008c0:	e000ed04 	.word	0xe000ed04
 80008c4:	200014f8 	.word	0x200014f8
 80008c8:	200014b0 	.word	0x200014b0

080008cc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80008cc:	b513      	push	{r0, r1, r4, lr}
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 80008ce:	4b11      	ldr	r3, [pc, #68]	; (8000914 <vTaskStartScheduler+0x48>)
 80008d0:	9301      	str	r3, [sp, #4]
 80008d2:	2400      	movs	r4, #0
 80008d4:	9400      	str	r4, [sp, #0]
 80008d6:	4623      	mov	r3, r4
 80008d8:	220a      	movs	r2, #10
 80008da:	490f      	ldr	r1, [pc, #60]	; (8000918 <vTaskStartScheduler+0x4c>)
 80008dc:	480f      	ldr	r0, [pc, #60]	; (800091c <vTaskStartScheduler+0x50>)
 80008de:	f7ff ff1d 	bl	800071c <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80008e2:	2801      	cmp	r0, #1
 80008e4:	d114      	bne.n	8000910 <vTaskStartScheduler+0x44>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80008e6:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 80008ea:	f383 8811 	msr	BASEPRI, r3
 80008ee:	f3bf 8f6f 	isb	sy
 80008f2:	f3bf 8f4f 	dsb	sy
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 80008f6:	4b0a      	ldr	r3, [pc, #40]	; (8000920 <vTaskStartScheduler+0x54>)
 80008f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80008fc:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 80008fe:	4b09      	ldr	r3, [pc, #36]	; (8000924 <vTaskStartScheduler+0x58>)
 8000900:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8000902:	4b09      	ldr	r3, [pc, #36]	; (8000928 <vTaskStartScheduler+0x5c>)
 8000904:	601c      	str	r4, [r3, #0]
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8000906:	b002      	add	sp, #8
 8000908:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800090c:	f7ff be7c 	b.w	8000608 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8000910:	b002      	add	sp, #8
 8000912:	bd10      	pop	{r4, pc}
 8000914:	200014d8 	.word	0x200014d8
 8000918:	080016e8 	.word	0x080016e8
 800091c:	08000649 	.word	0x08000649
 8000920:	200014dc 	.word	0x200014dc
 8000924:	200014f8 	.word	0x200014f8
 8000928:	20001510 	.word	0x20001510

0800092c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800092c:	4a02      	ldr	r2, [pc, #8]	; (8000938 <vTaskSuspendAll+0xc>)
 800092e:	6813      	ldr	r3, [r2, #0]
 8000930:	3301      	adds	r3, #1
 8000932:	6013      	str	r3, [r2, #0]
 8000934:	4770      	bx	lr
 8000936:	bf00      	nop
 8000938:	200014a4 	.word	0x200014a4

0800093c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 800093c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000940:	4b36      	ldr	r3, [pc, #216]	; (8000a1c <xTaskIncrementTick+0xe0>)
 8000942:	681b      	ldr	r3, [r3, #0]
 8000944:	2b00      	cmp	r3, #0
 8000946:	d147      	bne.n	80009d8 <xTaskIncrementTick+0x9c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 8000948:	4b35      	ldr	r3, [pc, #212]	; (8000a20 <xTaskIncrementTick+0xe4>)
 800094a:	681c      	ldr	r4, [r3, #0]
 800094c:	3401      	adds	r4, #1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 800094e:	601c      	str	r4, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
 8000950:	b95c      	cbnz	r4, 800096a <xTaskIncrementTick+0x2e>
		{
			taskSWITCH_DELAYED_LISTS();
 8000952:	4a34      	ldr	r2, [pc, #208]	; (8000a24 <xTaskIncrementTick+0xe8>)
 8000954:	4b34      	ldr	r3, [pc, #208]	; (8000a28 <xTaskIncrementTick+0xec>)
 8000956:	6811      	ldr	r1, [r2, #0]
 8000958:	6818      	ldr	r0, [r3, #0]
 800095a:	6010      	str	r0, [r2, #0]
 800095c:	4a33      	ldr	r2, [pc, #204]	; (8000a2c <xTaskIncrementTick+0xf0>)
 800095e:	6019      	str	r1, [r3, #0]
 8000960:	6813      	ldr	r3, [r2, #0]
 8000962:	3301      	adds	r3, #1
 8000964:	6013      	str	r3, [r2, #0]
 8000966:	f7ff fe81 	bl	800066c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 800096a:	4d31      	ldr	r5, [pc, #196]	; (8000a30 <xTaskIncrementTick+0xf4>)
 800096c:	4f31      	ldr	r7, [pc, #196]	; (8000a34 <xTaskIncrementTick+0xf8>)
 800096e:	682b      	ldr	r3, [r5, #0]
 8000970:	429c      	cmp	r4, r3
 8000972:	f04f 0b00 	mov.w	fp, #0
 8000976:	d33e      	bcc.n	80009f6 <xTaskIncrementTick+0xba>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000978:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8000a24 <xTaskIncrementTick+0xe8>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 800097c:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8000a44 <xTaskIncrementTick+0x108>
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000980:	f8d8 2000 	ldr.w	r2, [r8]
 8000984:	6812      	ldr	r2, [r2, #0]
 8000986:	bb72      	cbnz	r2, 80009e6 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000988:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800098c:	602a      	str	r2, [r5, #0]
					break;
 800098e:	e032      	b.n	80009f6 <xTaskIncrementTick+0xba>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000990:	f106 0a04 	add.w	sl, r6, #4
 8000994:	4650      	mov	r0, sl
 8000996:	f000 fb86 	bl	80010a6 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800099a:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 800099c:	b119      	cbz	r1, 80009a6 <xTaskIncrementTick+0x6a>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800099e:	f106 0018 	add.w	r0, r6, #24
 80009a2:	f000 fb80 	bl	80010a6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 80009a6:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80009a8:	f8d9 3000 	ldr.w	r3, [r9]
 80009ac:	2201      	movs	r2, #1
 80009ae:	fa02 f100 	lsl.w	r1, r2, r0
 80009b2:	4319      	orrs	r1, r3
 80009b4:	4b20      	ldr	r3, [pc, #128]	; (8000a38 <xTaskIncrementTick+0xfc>)
 80009b6:	f8c9 1000 	str.w	r1, [r9]
 80009ba:	f04f 0e14 	mov.w	lr, #20
 80009be:	4651      	mov	r1, sl
 80009c0:	fb0e 3000 	mla	r0, lr, r0, r3
 80009c4:	f000 fb4c 	bl	8001060 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80009c8:	6838      	ldr	r0, [r7, #0]
 80009ca:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 80009cc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
						{
							xSwitchRequired = pdTRUE;
 80009ce:	4291      	cmp	r1, r2
 80009d0:	bf28      	it	cs
 80009d2:	f04f 0b01 	movcs.w	fp, #1
 80009d6:	e7d3      	b.n	8000980 <xTaskIncrementTick+0x44>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 80009d8:	4a18      	ldr	r2, [pc, #96]	; (8000a3c <xTaskIncrementTick+0x100>)
 80009da:	6813      	ldr	r3, [r2, #0]
 80009dc:	3301      	adds	r3, #1
 80009de:	6013      	str	r3, [r2, #0]

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80009e0:	f04f 0b00 	mov.w	fp, #0
 80009e4:	e011      	b.n	8000a0a <xTaskIncrementTick+0xce>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80009e6:	f8d8 2000 	ldr.w	r2, [r8]
 80009ea:	68d2      	ldr	r2, [r2, #12]
 80009ec:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80009ee:	6871      	ldr	r1, [r6, #4]

					if( xConstTickCount < xItemValue )
 80009f0:	428c      	cmp	r4, r1
 80009f2:	d2cd      	bcs.n	8000990 <xTaskIncrementTick+0x54>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 80009f4:	6029      	str	r1, [r5, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80009f6:	683a      	ldr	r2, [r7, #0]
 80009f8:	4b0f      	ldr	r3, [pc, #60]	; (8000a38 <xTaskIncrementTick+0xfc>)
 80009fa:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 80009fc:	2214      	movs	r2, #20
 80009fe:	434a      	muls	r2, r1
 8000a00:	589a      	ldr	r2, [r3, r2]
			{
				xSwitchRequired = pdTRUE;
 8000a02:	2a02      	cmp	r2, #2
 8000a04:	bf28      	it	cs
 8000a06:	f04f 0b01 	movcs.w	fp, #1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8000a0a:	4a0d      	ldr	r2, [pc, #52]	; (8000a40 <xTaskIncrementTick+0x104>)
 8000a0c:	6812      	ldr	r2, [r2, #0]
		{
			xSwitchRequired = pdTRUE;
 8000a0e:	2a00      	cmp	r2, #0
 8000a10:	bf18      	it	ne
 8000a12:	f04f 0b01 	movne.w	fp, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 8000a16:	4658      	mov	r0, fp
 8000a18:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a1c:	200014a4 	.word	0x200014a4
 8000a20:	20001510 	.word	0x20001510
 8000a24:	20001430 	.word	0x20001430
 8000a28:	20001434 	.word	0x20001434
 8000a2c:	200014e0 	.word	0x200014e0
 8000a30:	200014dc 	.word	0x200014dc
 8000a34:	2000142c 	.word	0x2000142c
 8000a38:	20001438 	.word	0x20001438
 8000a3c:	200014a0 	.word	0x200014a0
 8000a40:	20001514 	.word	0x20001514
 8000a44:	200014ac 	.word	0x200014ac

08000a48 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8000a48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8000a4c:	f7ff fd6a 	bl	8000524 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8000a50:	4b2a      	ldr	r3, [pc, #168]	; (8000afc <xTaskResumeAll+0xb4>)
 8000a52:	681a      	ldr	r2, [r3, #0]
 8000a54:	3a01      	subs	r2, #1
 8000a56:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000a58:	681c      	ldr	r4, [r3, #0]
 8000a5a:	b12c      	cbz	r4, 8000a68 <xTaskResumeAll+0x20>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
 8000a5c:	2400      	movs	r4, #0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8000a5e:	f7ff fd71 	bl	8000544 <vPortExitCritical>

	return xAlreadyYielded;
}
 8000a62:	4620      	mov	r0, r4
 8000a64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8000a68:	4b25      	ldr	r3, [pc, #148]	; (8000b00 <xTaskResumeAll+0xb8>)
 8000a6a:	681b      	ldr	r3, [r3, #0]
 8000a6c:	2b00      	cmp	r3, #0
 8000a6e:	d0f5      	beq.n	8000a5c <xTaskResumeAll+0x14>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000a70:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8000b18 <xTaskResumeAll+0xd0>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
 8000a74:	4f23      	ldr	r7, [pc, #140]	; (8000b04 <xTaskResumeAll+0xbc>)
 8000a76:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8000b1c <xTaskResumeAll+0xd4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000a7a:	f8d9 3000 	ldr.w	r3, [r9]
 8000a7e:	b9e3      	cbnz	r3, 8000aba <xTaskResumeAll+0x72>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 8000a80:	b10c      	cbz	r4, 8000a86 <xTaskResumeAll+0x3e>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 8000a82:	f7ff fdf3 	bl	800066c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8000a86:	4d20      	ldr	r5, [pc, #128]	; (8000b08 <xTaskResumeAll+0xc0>)
 8000a88:	682c      	ldr	r4, [r5, #0]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8000a8a:	b144      	cbz	r4, 8000a9e <xTaskResumeAll+0x56>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
 8000a8c:	4e1f      	ldr	r6, [pc, #124]	; (8000b0c <xTaskResumeAll+0xc4>)
 8000a8e:	2701      	movs	r7, #1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 8000a90:	f7ff ff54 	bl	800093c <xTaskIncrementTick>
 8000a94:	b100      	cbz	r0, 8000a98 <xTaskResumeAll+0x50>
							{
								xYieldPending = pdTRUE;
 8000a96:	6037      	str	r7, [r6, #0]
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8000a98:	3c01      	subs	r4, #1
 8000a9a:	d1f9      	bne.n	8000a90 <xTaskResumeAll+0x48>

						uxPendedTicks = 0;
 8000a9c:	602c      	str	r4, [r5, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 8000a9e:	4b1b      	ldr	r3, [pc, #108]	; (8000b0c <xTaskResumeAll+0xc4>)
 8000aa0:	681b      	ldr	r3, [r3, #0]
 8000aa2:	2b00      	cmp	r3, #0
 8000aa4:	d0da      	beq.n	8000a5c <xTaskResumeAll+0x14>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8000aa6:	4b1a      	ldr	r3, [pc, #104]	; (8000b10 <xTaskResumeAll+0xc8>)
 8000aa8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000aac:	601a      	str	r2, [r3, #0]
 8000aae:	f3bf 8f4f 	dsb	sy
 8000ab2:	f3bf 8f6f 	isb	sy

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 8000ab6:	2401      	movs	r4, #1
 8000ab8:	e7d1      	b.n	8000a5e <xTaskResumeAll+0x16>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8000aba:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8000abe:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000ac0:	1d26      	adds	r6, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8000ac2:	f104 0018 	add.w	r0, r4, #24
 8000ac6:	f000 faee 	bl	80010a6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000aca:	4630      	mov	r0, r6
 8000acc:	f000 faeb 	bl	80010a6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000ad0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000ad2:	6839      	ldr	r1, [r7, #0]
 8000ad4:	2501      	movs	r5, #1
 8000ad6:	fa05 f302 	lsl.w	r3, r5, r2
 8000ada:	2014      	movs	r0, #20
 8000adc:	430b      	orrs	r3, r1
 8000ade:	fb00 8002 	mla	r0, r0, r2, r8
 8000ae2:	4631      	mov	r1, r6
 8000ae4:	603b      	str	r3, [r7, #0]
 8000ae6:	f000 fabb 	bl	8001060 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000aea:	4b0a      	ldr	r3, [pc, #40]	; (8000b14 <xTaskResumeAll+0xcc>)
 8000aec:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000aee:	681b      	ldr	r3, [r3, #0]
 8000af0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000af2:	429a      	cmp	r2, r3
					{
						xYieldPending = pdTRUE;
 8000af4:	bf24      	itt	cs
 8000af6:	4b05      	ldrcs	r3, [pc, #20]	; (8000b0c <xTaskResumeAll+0xc4>)
 8000af8:	601d      	strcs	r5, [r3, #0]
 8000afa:	e7be      	b.n	8000a7a <xTaskResumeAll+0x32>
 8000afc:	200014a4 	.word	0x200014a4
 8000b00:	2000149c 	.word	0x2000149c
 8000b04:	200014ac 	.word	0x200014ac
 8000b08:	200014a0 	.word	0x200014a0
 8000b0c:	20001514 	.word	0x20001514
 8000b10:	e000ed04 	.word	0xe000ed04
 8000b14:	2000142c 	.word	0x2000142c
 8000b18:	200014e4 	.word	0x200014e4
 8000b1c:	20001438 	.word	0x20001438

08000b20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8000b20:	b508      	push	{r3, lr}
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8000b22:	b940      	cbnz	r0, 8000b36 <vTaskDelay+0x16>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8000b24:	4b09      	ldr	r3, [pc, #36]	; (8000b4c <vTaskDelay+0x2c>)
 8000b26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000b2a:	601a      	str	r2, [r3, #0]
 8000b2c:	f3bf 8f4f 	dsb	sy
 8000b30:	f3bf 8f6f 	isb	sy
 8000b34:	bd08      	pop	{r3, pc}

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 8000b36:	f7ff fef9 	bl	800092c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8000b3a:	2100      	movs	r1, #0
 8000b3c:	f7ff fda8 	bl	8000690 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8000b40:	f7ff ff82 	bl	8000a48 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8000b44:	2800      	cmp	r0, #0
 8000b46:	d0ed      	beq.n	8000b24 <vTaskDelay+0x4>
 8000b48:	bd08      	pop	{r3, pc}
 8000b4a:	bf00      	nop
 8000b4c:	e000ed04 	.word	0xe000ed04

08000b50 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000b50:	4b11      	ldr	r3, [pc, #68]	; (8000b98 <vTaskSwitchContext+0x48>)
 8000b52:	681a      	ldr	r2, [r3, #0]
 8000b54:	4b11      	ldr	r3, [pc, #68]	; (8000b9c <vTaskSwitchContext+0x4c>)

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8000b56:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000b58:	b112      	cbz	r2, 8000b60 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8000b5a:	2201      	movs	r2, #1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8000b5c:	601a      	str	r2, [r3, #0]
 8000b5e:	bd30      	pop	{r4, r5, pc}
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 8000b60:	601a      	str	r2, [r3, #0]
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8000b62:	4b0f      	ldr	r3, [pc, #60]	; (8000ba0 <vTaskSwitchContext+0x50>)
 8000b64:	681b      	ldr	r3, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8000b66:	fab3 f383 	clz	r3, r3
 8000b6a:	b2db      	uxtb	r3, r3
 8000b6c:	490d      	ldr	r1, [pc, #52]	; (8000ba4 <vTaskSwitchContext+0x54>)
 8000b6e:	f1c3 031f 	rsb	r3, r3, #31
 8000b72:	2014      	movs	r0, #20
 8000b74:	fb00 f203 	mul.w	r2, r0, r3
 8000b78:	188c      	adds	r4, r1, r2
 8000b7a:	3208      	adds	r2, #8
 8000b7c:	6865      	ldr	r5, [r4, #4]
 8000b7e:	686d      	ldr	r5, [r5, #4]
 8000b80:	6065      	str	r5, [r4, #4]
 8000b82:	440a      	add	r2, r1
 8000b84:	4295      	cmp	r5, r2
 8000b86:	bf04      	itt	eq
 8000b88:	686a      	ldreq	r2, [r5, #4]
 8000b8a:	6062      	streq	r2, [r4, #4]
 8000b8c:	fb00 1303 	mla	r3, r0, r3, r1
 8000b90:	685b      	ldr	r3, [r3, #4]
 8000b92:	68da      	ldr	r2, [r3, #12]
 8000b94:	4b04      	ldr	r3, [pc, #16]	; (8000ba8 <vTaskSwitchContext+0x58>)
 8000b96:	e7e1      	b.n	8000b5c <vTaskSwitchContext+0xc>
 8000b98:	200014a4 	.word	0x200014a4
 8000b9c:	20001514 	.word	0x20001514
 8000ba0:	200014ac 	.word	0x200014ac
 8000ba4:	20001438 	.word	0x20001438
 8000ba8:	2000142c 	.word	0x2000142c

08000bac <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 8000bac:	b510      	push	{r4, lr}

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8000bae:	4b06      	ldr	r3, [pc, #24]	; (8000bc8 <vTaskPlaceOnEventList+0x1c>)
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 8000bb0:	460c      	mov	r4, r1

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8000bb2:	6819      	ldr	r1, [r3, #0]
 8000bb4:	3118      	adds	r1, #24
 8000bb6:	f000 fa5f 	bl	8001078 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8000bba:	4620      	mov	r0, r4
 8000bbc:	2101      	movs	r1, #1
}
 8000bbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8000bc2:	f7ff bd65 	b.w	8000690 <prvAddCurrentTaskToDelayedList>
 8000bc6:	bf00      	nop
 8000bc8:	2000142c 	.word	0x2000142c

08000bcc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 8000bcc:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8000bce:	68c3      	ldr	r3, [r0, #12]
 8000bd0:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8000bd2:	f104 0518 	add.w	r5, r4, #24
 8000bd6:	4628      	mov	r0, r5
 8000bd8:	f000 fa65 	bl	80010a6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000bdc:	4b11      	ldr	r3, [pc, #68]	; (8000c24 <xTaskRemoveFromEventList+0x58>)
 8000bde:	681b      	ldr	r3, [r3, #0]
 8000be0:	b9e3      	cbnz	r3, 8000c1c <xTaskRemoveFromEventList+0x50>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8000be2:	1d25      	adds	r5, r4, #4
 8000be4:	4628      	mov	r0, r5
 8000be6:	f000 fa5e 	bl	80010a6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8000bea:	490f      	ldr	r1, [pc, #60]	; (8000c28 <xTaskRemoveFromEventList+0x5c>)
 8000bec:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000bee:	6808      	ldr	r0, [r1, #0]
 8000bf0:	2301      	movs	r3, #1
 8000bf2:	4093      	lsls	r3, r2
 8000bf4:	4303      	orrs	r3, r0
 8000bf6:	600b      	str	r3, [r1, #0]
 8000bf8:	4b0c      	ldr	r3, [pc, #48]	; (8000c2c <xTaskRemoveFromEventList+0x60>)
 8000bfa:	2014      	movs	r0, #20
 8000bfc:	4629      	mov	r1, r5
 8000bfe:	fb00 3002 	mla	r0, r0, r2, r3
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8000c02:	f000 fa2d 	bl	8001060 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8000c06:	4b0a      	ldr	r3, [pc, #40]	; (8000c30 <xTaskRemoveFromEventList+0x64>)
 8000c08:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000c0a:	681b      	ldr	r3, [r3, #0]
 8000c0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000c0e:	429a      	cmp	r2, r3
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8000c10:	bf83      	ittte	hi
 8000c12:	4b08      	ldrhi	r3, [pc, #32]	; (8000c34 <xTaskRemoveFromEventList+0x68>)
 8000c14:	2001      	movhi	r0, #1
 8000c16:	6018      	strhi	r0, [r3, #0]
	}
	else
	{
		xReturn = pdFALSE;
 8000c18:	2000      	movls	r0, #0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
 8000c1a:	bd38      	pop	{r3, r4, r5, pc}
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8000c1c:	4629      	mov	r1, r5
 8000c1e:	4806      	ldr	r0, [pc, #24]	; (8000c38 <xTaskRemoveFromEventList+0x6c>)
 8000c20:	e7ef      	b.n	8000c02 <xTaskRemoveFromEventList+0x36>
 8000c22:	bf00      	nop
 8000c24:	200014a4 	.word	0x200014a4
 8000c28:	200014ac 	.word	0x200014ac
 8000c2c:	20001438 	.word	0x20001438
 8000c30:	2000142c 	.word	0x2000142c
 8000c34:	20001514 	.word	0x20001514
 8000c38:	200014e4 	.word	0x200014e4

08000c3c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8000c3c:	4b03      	ldr	r3, [pc, #12]	; (8000c4c <vTaskSetTimeOutState+0x10>)
 8000c3e:	681b      	ldr	r3, [r3, #0]
 8000c40:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8000c42:	4b03      	ldr	r3, [pc, #12]	; (8000c50 <vTaskSetTimeOutState+0x14>)
 8000c44:	681b      	ldr	r3, [r3, #0]
 8000c46:	6043      	str	r3, [r0, #4]
 8000c48:	4770      	bx	lr
 8000c4a:	bf00      	nop
 8000c4c:	200014e0 	.word	0x200014e0
 8000c50:	20001510 	.word	0x20001510

08000c54 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 8000c54:	b538      	push	{r3, r4, r5, lr}
 8000c56:	460d      	mov	r5, r1
 8000c58:	4604      	mov	r4, r0
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 8000c5a:	f7ff fc63 	bl	8000524 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8000c5e:	4b0e      	ldr	r3, [pc, #56]	; (8000c98 <xTaskCheckForTimeOut+0x44>)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 8000c60:	682a      	ldr	r2, [r5, #0]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8000c62:	6818      	ldr	r0, [r3, #0]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 8000c64:	1c53      	adds	r3, r2, #1
 8000c66:	d010      	beq.n	8000c8a <xTaskCheckForTimeOut+0x36>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8000c68:	4b0c      	ldr	r3, [pc, #48]	; (8000c9c <xTaskCheckForTimeOut+0x48>)
 8000c6a:	6821      	ldr	r1, [r4, #0]
 8000c6c:	681b      	ldr	r3, [r3, #0]
 8000c6e:	4299      	cmp	r1, r3
 8000c70:	6863      	ldr	r3, [r4, #4]
 8000c72:	d001      	beq.n	8000c78 <xTaskCheckForTimeOut+0x24>
 8000c74:	4298      	cmp	r0, r3
 8000c76:	d20d      	bcs.n	8000c94 <xTaskCheckForTimeOut+0x40>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8000c78:	1ac1      	subs	r1, r0, r3
 8000c7a:	428a      	cmp	r2, r1
 8000c7c:	d90a      	bls.n	8000c94 <xTaskCheckForTimeOut+0x40>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8000c7e:	1a1b      	subs	r3, r3, r0
 8000c80:	4413      	add	r3, r2
 8000c82:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8000c84:	4620      	mov	r0, r4
 8000c86:	f7ff ffd9 	bl	8000c3c <vTaskSetTimeOutState>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 8000c8a:	2400      	movs	r4, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8000c8c:	f7ff fc5a 	bl	8000544 <vPortExitCritical>

	return xReturn;
}
 8000c90:	4620      	mov	r0, r4
 8000c92:	bd38      	pop	{r3, r4, r5, pc}
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 8000c94:	2401      	movs	r4, #1
 8000c96:	e7f9      	b.n	8000c8c <xTaskCheckForTimeOut+0x38>
 8000c98:	20001510 	.word	0x20001510
 8000c9c:	200014e0 	.word	0x200014e0

08000ca0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 8000ca0:	4b01      	ldr	r3, [pc, #4]	; (8000ca8 <vTaskMissedYield+0x8>)
 8000ca2:	2201      	movs	r2, #1
 8000ca4:	601a      	str	r2, [r3, #0]
 8000ca6:	4770      	bx	lr
 8000ca8:	20001514 	.word	0x20001514

08000cac <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8000cac:	b570      	push	{r4, r5, r6, lr}
 8000cae:	4616      	mov	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8000cb0:	6c02      	ldr	r2, [r0, #64]	; 0x40
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000cb2:	6b85      	ldr	r5, [r0, #56]	; 0x38

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8000cb4:	4604      	mov	r4, r0

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8000cb6:	b162      	cbz	r2, 8000cd2 <prvCopyDataToQueue+0x26>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8000cb8:	b97e      	cbnz	r6, 8000cda <prvCopyDataToQueue+0x2e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8000cba:	6880      	ldr	r0, [r0, #8]
 8000cbc:	f000 fc48 	bl	8001550 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8000cc0:	68a3      	ldr	r3, [r4, #8]
 8000cc2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000cc4:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000cc6:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8000cc8:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000cca:	4293      	cmp	r3, r2
 8000ccc:	d301      	bcc.n	8000cd2 <prvCopyDataToQueue+0x26>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8000cce:	6823      	ldr	r3, [r4, #0]
 8000cd0:	60a3      	str	r3, [r4, #8]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8000cd2:	3501      	adds	r5, #1
 8000cd4:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 8000cd6:	2000      	movs	r0, #0
 8000cd8:	bd70      	pop	{r4, r5, r6, pc}
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000cda:	68c0      	ldr	r0, [r0, #12]
 8000cdc:	f000 fc38 	bl	8001550 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8000ce0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000ce2:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000ce4:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8000ce6:	425b      	negs	r3, r3
 8000ce8:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000cea:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8000cec:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8000cee:	bf3e      	ittt	cc
 8000cf0:	6862      	ldrcc	r2, [r4, #4]
 8000cf2:	189b      	addcc	r3, r3, r2
 8000cf4:	60e3      	strcc	r3, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 8000cf6:	2e02      	cmp	r6, #2
 8000cf8:	d1eb      	bne.n	8000cd2 <prvCopyDataToQueue+0x26>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000cfa:	2d00      	cmp	r5, #0
 8000cfc:	d0e9      	beq.n	8000cd2 <prvCopyDataToQueue+0x26>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 8000cfe:	3d01      	subs	r5, #1
 8000d00:	e7e7      	b.n	8000cd2 <prvCopyDataToQueue+0x26>

08000d02 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8000d02:	4603      	mov	r3, r0
 8000d04:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000d06:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8000d08:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000d0a:	b162      	cbz	r2, 8000d26 <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8000d0c:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000d0e:	685c      	ldr	r4, [r3, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8000d10:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000d12:	42a1      	cmp	r1, r4

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8000d14:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8000d16:	bf24      	itt	cs
 8000d18:	6819      	ldrcs	r1, [r3, #0]
 8000d1a:	60d9      	strcs	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8000d1c:	68d9      	ldr	r1, [r3, #12]
	}
}
 8000d1e:	f85d 4b04 	ldr.w	r4, [sp], #4
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8000d22:	f000 bc15 	b.w	8001550 <memcpy>
	}
}
 8000d26:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000d2a:	4770      	bx	lr

08000d2c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8000d2c:	b570      	push	{r4, r5, r6, lr}
 8000d2e:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8000d30:	f7ff fbf8 	bl	8000524 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8000d34:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000d38:	f104 0624 	add.w	r6, r4, #36	; 0x24
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8000d3c:	b26d      	sxtb	r5, r5

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8000d3e:	2d00      	cmp	r5, #0
 8000d40:	dc14      	bgt.n	8000d6c <prvUnlockQueue+0x40>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8000d42:	23ff      	movs	r3, #255	; 0xff
 8000d44:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8000d48:	f7ff fbfc 	bl	8000544 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8000d4c:	f7ff fbea 	bl	8000524 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8000d50:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d54:	f104 0610 	add.w	r6, r4, #16
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8000d58:	b26d      	sxtb	r5, r5

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d5a:	2d00      	cmp	r5, #0
 8000d5c:	dc12      	bgt.n	8000d84 <prvUnlockQueue+0x58>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8000d5e:	23ff      	movs	r3, #255	; 0xff
 8000d60:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8000d64:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8000d68:	f7ff bbec 	b.w	8000544 <vPortExitCritical>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000d6c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000d6e:	2b00      	cmp	r3, #0
 8000d70:	d0e7      	beq.n	8000d42 <prvUnlockQueue+0x16>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000d72:	4630      	mov	r0, r6
 8000d74:	f7ff ff2a 	bl	8000bcc <xTaskRemoveFromEventList>
 8000d78:	b108      	cbz	r0, 8000d7e <prvUnlockQueue+0x52>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 8000d7a:	f7ff ff91 	bl	8000ca0 <vTaskMissedYield>
 8000d7e:	3d01      	subs	r5, #1
 8000d80:	b26d      	sxtb	r5, r5
 8000d82:	e7dc      	b.n	8000d3e <prvUnlockQueue+0x12>
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000d84:	6923      	ldr	r3, [r4, #16]
 8000d86:	2b00      	cmp	r3, #0
 8000d88:	d0e9      	beq.n	8000d5e <prvUnlockQueue+0x32>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d8a:	4630      	mov	r0, r6
 8000d8c:	f7ff ff1e 	bl	8000bcc <xTaskRemoveFromEventList>
 8000d90:	b108      	cbz	r0, 8000d96 <prvUnlockQueue+0x6a>
				{
					vTaskMissedYield();
 8000d92:	f7ff ff85 	bl	8000ca0 <vTaskMissedYield>
 8000d96:	3d01      	subs	r5, #1
 8000d98:	b26d      	sxtb	r5, r5
 8000d9a:	e7de      	b.n	8000d5a <prvUnlockQueue+0x2e>

08000d9c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 8000d9c:	b538      	push	{r3, r4, r5, lr}
 8000d9e:	4604      	mov	r4, r0
 8000da0:	460d      	mov	r5, r1
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 8000da2:	f7ff fbbf 	bl	8000524 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8000da6:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8000da8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000daa:	6822      	ldr	r2, [r4, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8000dac:	60a2      	str	r2, [r4, #8]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8000dae:	4343      	muls	r3, r0
 8000db0:	18d1      	adds	r1, r2, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8000db2:	1a1b      	subs	r3, r3, r0
 8000db4:	4413      	add	r3, r2

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8000db6:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8000db8:	60e3      	str	r3, [r4, #12]
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8000dba:	2100      	movs	r1, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
 8000dbc:	23ff      	movs	r3, #255	; 0xff
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8000dbe:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
 8000dc0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8000dc4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45

		if( xNewQueue == pdFALSE )
 8000dc8:	b995      	cbnz	r5, 8000df0 <xQueueGenericReset+0x54>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000dca:	6923      	ldr	r3, [r4, #16]
 8000dcc:	b163      	cbz	r3, 8000de8 <xQueueGenericReset+0x4c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000dce:	f104 0010 	add.w	r0, r4, #16
 8000dd2:	f7ff fefb 	bl	8000bcc <xTaskRemoveFromEventList>
 8000dd6:	b138      	cbz	r0, 8000de8 <xQueueGenericReset+0x4c>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8000dd8:	4b0a      	ldr	r3, [pc, #40]	; (8000e04 <xQueueGenericReset+0x68>)
 8000dda:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000dde:	601a      	str	r2, [r3, #0]
 8000de0:	f3bf 8f4f 	dsb	sy
 8000de4:	f3bf 8f6f 	isb	sy
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
 8000de8:	f7ff fbac 	bl	8000544 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8000dec:	2001      	movs	r0, #1
 8000dee:	bd38      	pop	{r3, r4, r5, pc}
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8000df0:	f104 0010 	add.w	r0, r4, #16
 8000df4:	f000 f926 	bl	8001044 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8000df8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8000dfc:	f000 f922 	bl	8001044 <vListInitialise>
 8000e00:	e7f2      	b.n	8000de8 <xQueueGenericReset+0x4c>
 8000e02:	bf00      	nop
 8000e04:	e000ed04 	.word	0xe000ed04

08000e08 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 8000e08:	b570      	push	{r4, r5, r6, lr}
 8000e0a:	4606      	mov	r6, r0
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000e0c:	4348      	muls	r0, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8000e0e:	3048      	adds	r0, #72	; 0x48
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 8000e10:	460d      	mov	r5, r1
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8000e12:	f7ff fabb 	bl	800038c <pvPortMalloc>

		if( pxNewQueue != NULL )
 8000e16:	4604      	mov	r4, r0
 8000e18:	b138      	cbz	r0, 8000e2a <xQueueGenericCreate+0x22>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 8000e1a:	b945      	cbnz	r5, 8000e2e <xQueueGenericCreate+0x26>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8000e1c:	6020      	str	r0, [r4, #0]
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 8000e1e:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8000e20:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8000e22:	2101      	movs	r1, #1
 8000e24:	4620      	mov	r0, r4
 8000e26:	f7ff ffb9 	bl	8000d9c <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
 8000e2a:	4620      	mov	r0, r4
 8000e2c:	bd70      	pop	{r4, r5, r6, pc}

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8000e2e:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8000e32:	6003      	str	r3, [r0, #0]
 8000e34:	e7f3      	b.n	8000e1e <xQueueGenericCreate+0x16>
	...

08000e38 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 8000e38:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 8000e3c:	2600      	movs	r6, #0
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
 8000e3e:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 8000f28 <xQueueGenericSend+0xf0>

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 8000e42:	9201      	str	r2, [sp, #4]
 8000e44:	4604      	mov	r4, r0
 8000e46:	4689      	mov	r9, r1
 8000e48:	461f      	mov	r7, r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8000e4a:	46b0      	mov	r8, r6
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8000e4c:	f7ff fb6a 	bl	8000524 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8000e50:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000e52:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000e54:	429a      	cmp	r2, r3
 8000e56:	d301      	bcc.n	8000e5c <xQueueGenericSend+0x24>
 8000e58:	2f02      	cmp	r7, #2
 8000e5a:	d119      	bne.n	8000e90 <xQueueGenericSend+0x58>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8000e5c:	463a      	mov	r2, r7
 8000e5e:	4649      	mov	r1, r9
 8000e60:	4620      	mov	r0, r4
 8000e62:	f7ff ff23 	bl	8000cac <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000e66:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000e68:	b11b      	cbz	r3, 8000e72 <xQueueGenericSend+0x3a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000e6a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8000e6e:	f7ff fead 	bl	8000bcc <xTaskRemoveFromEventList>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 8000e72:	b138      	cbz	r0, 8000e84 <xQueueGenericSend+0x4c>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 8000e74:	4b2c      	ldr	r3, [pc, #176]	; (8000f28 <xQueueGenericSend+0xf0>)
 8000e76:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000e7a:	601a      	str	r2, [r3, #0]
 8000e7c:	f3bf 8f4f 	dsb	sy
 8000e80:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8000e84:	f7ff fb5e 	bl	8000544 <vPortExitCritical>
				return pdPASS;
 8000e88:	2001      	movs	r0, #1

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 8000e8a:	b004      	add	sp, #16
 8000e8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8000e90:	9d01      	ldr	r5, [sp, #4]
 8000e92:	b91d      	cbnz	r5, 8000e9c <xQueueGenericSend+0x64>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8000e94:	f7ff fb56 	bl	8000544 <vPortExitCritical>
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8000e98:	2000      	movs	r0, #0
 8000e9a:	e7f6      	b.n	8000e8a <xQueueGenericSend+0x52>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 8000e9c:	b916      	cbnz	r6, 8000ea4 <xQueueGenericSend+0x6c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8000e9e:	a802      	add	r0, sp, #8
 8000ea0:	f7ff fecc 	bl	8000c3c <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8000ea4:	f7ff fb4e 	bl	8000544 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8000ea8:	f7ff fd40 	bl	800092c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8000eac:	f7ff fb3a 	bl	8000524 <vPortEnterCritical>
 8000eb0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000eb4:	2bff      	cmp	r3, #255	; 0xff
 8000eb6:	bf08      	it	eq
 8000eb8:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 8000ebc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000ec0:	2bff      	cmp	r3, #255	; 0xff
 8000ec2:	bf08      	it	eq
 8000ec4:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8000ec8:	f7ff fb3c 	bl	8000544 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000ecc:	a901      	add	r1, sp, #4
 8000ece:	a802      	add	r0, sp, #8
 8000ed0:	f7ff fec0 	bl	8000c54 <xTaskCheckForTimeOut>
 8000ed4:	bb10      	cbnz	r0, 8000f1c <xQueueGenericSend+0xe4>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8000ed6:	f7ff fb25 	bl	8000524 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8000eda:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8000edc:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8000ede:	f7ff fb31 	bl	8000544 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8000ee2:	42ae      	cmp	r6, r5
 8000ee4:	d114      	bne.n	8000f10 <xQueueGenericSend+0xd8>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8000ee6:	9901      	ldr	r1, [sp, #4]
 8000ee8:	f104 0010 	add.w	r0, r4, #16
 8000eec:	f7ff fe5e 	bl	8000bac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8000ef0:	4620      	mov	r0, r4
 8000ef2:	f7ff ff1b 	bl	8000d2c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8000ef6:	f7ff fda7 	bl	8000a48 <xTaskResumeAll>
 8000efa:	b938      	cbnz	r0, 8000f0c <xQueueGenericSend+0xd4>
				{
					portYIELD_WITHIN_API();
 8000efc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000f00:	f8ca 3000 	str.w	r3, [sl]
 8000f04:	f3bf 8f4f 	dsb	sy
 8000f08:	f3bf 8f6f 	isb	sy
 8000f0c:	2601      	movs	r6, #1
 8000f0e:	e79d      	b.n	8000e4c <xQueueGenericSend+0x14>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8000f10:	4620      	mov	r0, r4
 8000f12:	f7ff ff0b 	bl	8000d2c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8000f16:	f7ff fd97 	bl	8000a48 <xTaskResumeAll>
 8000f1a:	e7f7      	b.n	8000f0c <xQueueGenericSend+0xd4>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8000f1c:	4620      	mov	r0, r4
 8000f1e:	f7ff ff05 	bl	8000d2c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8000f22:	f7ff fd91 	bl	8000a48 <xTaskResumeAll>
 8000f26:	e7b7      	b.n	8000e98 <xQueueGenericSend+0x60>
 8000f28:	e000ed04 	.word	0xe000ed04

08000f2c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8000f2c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
BaseType_t xEntryTimeSet = pdFALSE;
 8000f30:	f04f 0a00 	mov.w	sl, #0

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
 8000f34:	f8df 9108 	ldr.w	r9, [pc, #264]	; 8001040 <xQueueGenericReceive+0x114>
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8000f38:	9201      	str	r2, [sp, #4]
 8000f3a:	4604      	mov	r4, r0
 8000f3c:	460f      	mov	r7, r1
 8000f3e:	4698      	mov	r8, r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8000f40:	4656      	mov	r6, sl
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8000f42:	f7ff faef 	bl	8000524 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000f46:	6ba5      	ldr	r5, [r4, #56]	; 0x38

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000f48:	b32d      	cbz	r5, 8000f96 <xQueueGenericReceive+0x6a>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8000f4a:	4639      	mov	r1, r7
 8000f4c:	4620      	mov	r0, r4
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8000f4e:	68e6      	ldr	r6, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8000f50:	f7ff fed7 	bl	8000d02 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8000f54:	f1b8 0f00 	cmp.w	r8, #0
 8000f58:	d116      	bne.n	8000f88 <xQueueGenericReceive+0x5c>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000f5a:	6923      	ldr	r3, [r4, #16]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8000f5c:	3d01      	subs	r5, #1
 8000f5e:	63a5      	str	r5, [r4, #56]	; 0x38
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000f60:	b163      	cbz	r3, 8000f7c <xQueueGenericReceive+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000f62:	f104 0010 	add.w	r0, r4, #16

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000f66:	f7ff fe31 	bl	8000bcc <xTaskRemoveFromEventList>
 8000f6a:	b138      	cbz	r0, 8000f7c <xQueueGenericReceive+0x50>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
 8000f6c:	4b34      	ldr	r3, [pc, #208]	; (8001040 <xQueueGenericReceive+0x114>)
 8000f6e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000f72:	601a      	str	r2, [r3, #0]
 8000f74:	f3bf 8f4f 	dsb	sy
 8000f78:	f3bf 8f6f 	isb	sy
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 8000f7c:	f7ff fae2 	bl	8000544 <vPortExitCritical>
				return pdPASS;
 8000f80:	2001      	movs	r0, #1
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
 8000f82:	b004      	add	sp, #16
 8000f84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000f88:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8000f8a:	60e6      	str	r6, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000f8c:	2b00      	cmp	r3, #0
 8000f8e:	d0f5      	beq.n	8000f7c <xQueueGenericReceive+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000f90:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8000f94:	e7e7      	b.n	8000f66 <xQueueGenericReceive+0x3a>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8000f96:	9d01      	ldr	r5, [sp, #4]
 8000f98:	b91d      	cbnz	r5, 8000fa2 <xQueueGenericReceive+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8000f9a:	f7ff fad3 	bl	8000544 <vPortExitCritical>
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 8000f9e:	4628      	mov	r0, r5
 8000fa0:	e7ef      	b.n	8000f82 <xQueueGenericReceive+0x56>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 8000fa2:	f1ba 0f00 	cmp.w	sl, #0
 8000fa6:	d102      	bne.n	8000fae <xQueueGenericReceive+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8000fa8:	a802      	add	r0, sp, #8
 8000faa:	f7ff fe47 	bl	8000c3c <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8000fae:	f7ff fac9 	bl	8000544 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8000fb2:	f7ff fcbb 	bl	800092c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8000fb6:	f7ff fab5 	bl	8000524 <vPortEnterCritical>
 8000fba:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000fbe:	2bff      	cmp	r3, #255	; 0xff
 8000fc0:	bf08      	it	eq
 8000fc2:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
 8000fc6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000fca:	2bff      	cmp	r3, #255	; 0xff
 8000fcc:	bf08      	it	eq
 8000fce:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
 8000fd2:	f7ff fab7 	bl	8000544 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000fd6:	a901      	add	r1, sp, #4
 8000fd8:	a802      	add	r0, sp, #8
 8000fda:	f7ff fe3b 	bl	8000c54 <xTaskCheckForTimeOut>
 8000fde:	bb08      	cbnz	r0, 8001024 <xQueueGenericReceive+0xf8>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8000fe0:	f7ff faa0 	bl	8000524 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8000fe4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8000fe6:	f7ff faad 	bl	8000544 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8000fea:	b9ad      	cbnz	r5, 8001018 <xQueueGenericReceive+0xec>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8000fec:	9901      	ldr	r1, [sp, #4]
 8000fee:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8000ff2:	f7ff fddb 	bl	8000bac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8000ff6:	4620      	mov	r0, r4
 8000ff8:	f7ff fe98 	bl	8000d2c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8000ffc:	f7ff fd24 	bl	8000a48 <xTaskResumeAll>
 8001000:	b938      	cbnz	r0, 8001012 <xQueueGenericReceive+0xe6>
				{
					portYIELD_WITHIN_API();
 8001002:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8001006:	f8c9 3000 	str.w	r3, [r9]
 800100a:	f3bf 8f4f 	dsb	sy
 800100e:	f3bf 8f6f 	isb	sy
 8001012:	f04f 0a01 	mov.w	sl, #1
 8001016:	e794      	b.n	8000f42 <xQueueGenericReceive+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8001018:	4620      	mov	r0, r4
 800101a:	f7ff fe87 	bl	8000d2c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800101e:	f7ff fd13 	bl	8000a48 <xTaskResumeAll>
 8001022:	e7f6      	b.n	8001012 <xQueueGenericReceive+0xe6>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8001024:	4620      	mov	r0, r4
 8001026:	f7ff fe81 	bl	8000d2c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800102a:	f7ff fd0d 	bl	8000a48 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800102e:	f7ff fa79 	bl	8000524 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8001032:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8001034:	f7ff fa86 	bl	8000544 <vPortExitCritical>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001038:	2d00      	cmp	r5, #0
 800103a:	d1ea      	bne.n	8001012 <xQueueGenericReceive+0xe6>
 800103c:	e7af      	b.n	8000f9e <xQueueGenericReceive+0x72>
 800103e:	bf00      	nop
 8001040:	e000ed04 	.word	0xe000ed04

08001044 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001044:	f100 0308 	add.w	r3, r0, #8
 8001048:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800104a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800104e:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001050:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001052:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001054:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001056:	6003      	str	r3, [r0, #0]
 8001058:	4770      	bx	lr

0800105a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800105a:	2300      	movs	r3, #0
 800105c:	6103      	str	r3, [r0, #16]
 800105e:	4770      	bx	lr

08001060 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8001060:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8001062:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001064:	689a      	ldr	r2, [r3, #8]
 8001066:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8001068:	689a      	ldr	r2, [r3, #8]
 800106a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800106c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800106e:	6803      	ldr	r3, [r0, #0]

	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001070:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8001072:	3301      	adds	r3, #1
 8001074:	6003      	str	r3, [r0, #0]
 8001076:	4770      	bx	lr

08001078 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8001078:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800107a:	1c53      	adds	r3, r2, #1
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800107c:	b530      	push	{r4, r5, lr}
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800107e:	d10a      	bne.n	8001096 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8001080:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8001082:	685a      	ldr	r2, [r3, #4]
 8001084:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8001086:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8001088:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800108a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800108c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800108e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8001090:	3301      	adds	r3, #1
 8001092:	6003      	str	r3, [r0, #0]
 8001094:	bd30      	pop	{r4, r5, pc}
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001096:	f100 0308 	add.w	r3, r0, #8
 800109a:	685c      	ldr	r4, [r3, #4]
 800109c:	6825      	ldr	r5, [r4, #0]
 800109e:	42aa      	cmp	r2, r5
 80010a0:	d3ef      	bcc.n	8001082 <vListInsert+0xa>
 80010a2:	4623      	mov	r3, r4
 80010a4:	e7f9      	b.n	800109a <vListInsert+0x22>

080010a6 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80010a6:	6841      	ldr	r1, [r0, #4]
 80010a8:	6882      	ldr	r2, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80010aa:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80010ac:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80010ae:	6882      	ldr	r2, [r0, #8]
 80010b0:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80010b2:	6859      	ldr	r1, [r3, #4]
 80010b4:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80010b6:	bf08      	it	eq
 80010b8:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 80010ba:	2200      	movs	r2, #0
 80010bc:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80010be:	6818      	ldr	r0, [r3, #0]
 80010c0:	3801      	subs	r0, #1
 80010c2:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 80010c4:	4770      	bx	lr
	...

080010c8 <rcc_is_osc_ready>:
 80010c8:	2806      	cmp	r0, #6
 80010ca:	d822      	bhi.n	8001112 <rcc_is_osc_ready+0x4a>
 80010cc:	e8df f000 	tbb	[pc, r0]
 80010d0:	091c1704 	.word	0x091c1704
 80010d4:	130e      	.short	0x130e
 80010d6:	15          	.byte	0x15
 80010d7:	00          	.byte	0x00
 80010d8:	4b0f      	ldr	r3, [pc, #60]	; (8001118 <rcc_is_osc_ready+0x50>)
 80010da:	6818      	ldr	r0, [r3, #0]
 80010dc:	f3c0 6040 	ubfx	r0, r0, #25, #1
 80010e0:	4770      	bx	lr
 80010e2:	4b0d      	ldr	r3, [pc, #52]	; (8001118 <rcc_is_osc_ready+0x50>)
 80010e4:	6818      	ldr	r0, [r3, #0]
 80010e6:	f3c0 4040 	ubfx	r0, r0, #17, #1
 80010ea:	4770      	bx	lr
 80010ec:	4b0a      	ldr	r3, [pc, #40]	; (8001118 <rcc_is_osc_ready+0x50>)
 80010ee:	6818      	ldr	r0, [r3, #0]
 80010f0:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80010f4:	4770      	bx	lr
 80010f6:	4b09      	ldr	r3, [pc, #36]	; (800111c <rcc_is_osc_ready+0x54>)
 80010f8:	e7f9      	b.n	80010ee <rcc_is_osc_ready+0x26>
 80010fa:	4b09      	ldr	r3, [pc, #36]	; (8001120 <rcc_is_osc_ready+0x58>)
 80010fc:	e7f7      	b.n	80010ee <rcc_is_osc_ready+0x26>
 80010fe:	4b06      	ldr	r3, [pc, #24]	; (8001118 <rcc_is_osc_ready+0x50>)
 8001100:	6818      	ldr	r0, [r3, #0]
 8001102:	f3c0 7040 	ubfx	r0, r0, #29, #1
 8001106:	4770      	bx	lr
 8001108:	4b03      	ldr	r3, [pc, #12]	; (8001118 <rcc_is_osc_ready+0x50>)
 800110a:	6818      	ldr	r0, [r3, #0]
 800110c:	f3c0 60c0 	ubfx	r0, r0, #27, #1
 8001110:	4770      	bx	lr
 8001112:	2000      	movs	r0, #0
 8001114:	4770      	bx	lr
 8001116:	bf00      	nop
 8001118:	40023800 	.word	0x40023800
 800111c:	40023870 	.word	0x40023870
 8001120:	40023874 	.word	0x40023874

08001124 <rcc_wait_for_osc_ready>:
 8001124:	b508      	push	{r3, lr}
 8001126:	4602      	mov	r2, r0
 8001128:	4610      	mov	r0, r2
 800112a:	f7ff ffcd 	bl	80010c8 <rcc_is_osc_ready>
 800112e:	2800      	cmp	r0, #0
 8001130:	d0fa      	beq.n	8001128 <rcc_wait_for_osc_ready+0x4>
 8001132:	bd08      	pop	{r3, pc}

08001134 <rcc_osc_on>:
 8001134:	2806      	cmp	r0, #6
 8001136:	d80a      	bhi.n	800114e <rcc_osc_on+0x1a>
 8001138:	e8df f000 	tbb	[pc, r0]
 800113c:	0a1d1804 	.word	0x0a1d1804
 8001140:	140f      	.short	0x140f
 8001142:	16          	.byte	0x16
 8001143:	00          	.byte	0x00
 8001144:	4a0e      	ldr	r2, [pc, #56]	; (8001180 <rcc_osc_on+0x4c>)
 8001146:	6813      	ldr	r3, [r2, #0]
 8001148:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800114c:	6013      	str	r3, [r2, #0]
 800114e:	4770      	bx	lr
 8001150:	4a0b      	ldr	r2, [pc, #44]	; (8001180 <rcc_osc_on+0x4c>)
 8001152:	6813      	ldr	r3, [r2, #0]
 8001154:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001158:	e7f8      	b.n	800114c <rcc_osc_on+0x18>
 800115a:	4a09      	ldr	r2, [pc, #36]	; (8001180 <rcc_osc_on+0x4c>)
 800115c:	6813      	ldr	r3, [r2, #0]
 800115e:	f043 0301 	orr.w	r3, r3, #1
 8001162:	e7f3      	b.n	800114c <rcc_osc_on+0x18>
 8001164:	4a07      	ldr	r2, [pc, #28]	; (8001184 <rcc_osc_on+0x50>)
 8001166:	e7f9      	b.n	800115c <rcc_osc_on+0x28>
 8001168:	4a07      	ldr	r2, [pc, #28]	; (8001188 <rcc_osc_on+0x54>)
 800116a:	e7f7      	b.n	800115c <rcc_osc_on+0x28>
 800116c:	4a04      	ldr	r2, [pc, #16]	; (8001180 <rcc_osc_on+0x4c>)
 800116e:	6813      	ldr	r3, [r2, #0]
 8001170:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001174:	e7ea      	b.n	800114c <rcc_osc_on+0x18>
 8001176:	4a02      	ldr	r2, [pc, #8]	; (8001180 <rcc_osc_on+0x4c>)
 8001178:	6813      	ldr	r3, [r2, #0]
 800117a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800117e:	e7e5      	b.n	800114c <rcc_osc_on+0x18>
 8001180:	40023800 	.word	0x40023800
 8001184:	40023870 	.word	0x40023870
 8001188:	40023874 	.word	0x40023874

0800118c <rcc_osc_off>:
 800118c:	2806      	cmp	r0, #6
 800118e:	d80a      	bhi.n	80011a6 <rcc_osc_off+0x1a>
 8001190:	e8df f000 	tbb	[pc, r0]
 8001194:	0a1d1804 	.word	0x0a1d1804
 8001198:	140f      	.short	0x140f
 800119a:	16          	.byte	0x16
 800119b:	00          	.byte	0x00
 800119c:	4a0e      	ldr	r2, [pc, #56]	; (80011d8 <rcc_osc_off+0x4c>)
 800119e:	6813      	ldr	r3, [r2, #0]
 80011a0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80011a4:	6013      	str	r3, [r2, #0]
 80011a6:	4770      	bx	lr
 80011a8:	4a0b      	ldr	r2, [pc, #44]	; (80011d8 <rcc_osc_off+0x4c>)
 80011aa:	6813      	ldr	r3, [r2, #0]
 80011ac:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80011b0:	e7f8      	b.n	80011a4 <rcc_osc_off+0x18>
 80011b2:	4a09      	ldr	r2, [pc, #36]	; (80011d8 <rcc_osc_off+0x4c>)
 80011b4:	6813      	ldr	r3, [r2, #0]
 80011b6:	f023 0301 	bic.w	r3, r3, #1
 80011ba:	e7f3      	b.n	80011a4 <rcc_osc_off+0x18>
 80011bc:	4a07      	ldr	r2, [pc, #28]	; (80011dc <rcc_osc_off+0x50>)
 80011be:	e7f9      	b.n	80011b4 <rcc_osc_off+0x28>
 80011c0:	4a07      	ldr	r2, [pc, #28]	; (80011e0 <rcc_osc_off+0x54>)
 80011c2:	e7f7      	b.n	80011b4 <rcc_osc_off+0x28>
 80011c4:	4a04      	ldr	r2, [pc, #16]	; (80011d8 <rcc_osc_off+0x4c>)
 80011c6:	6813      	ldr	r3, [r2, #0]
 80011c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80011cc:	e7ea      	b.n	80011a4 <rcc_osc_off+0x18>
 80011ce:	4a02      	ldr	r2, [pc, #8]	; (80011d8 <rcc_osc_off+0x4c>)
 80011d0:	6813      	ldr	r3, [r2, #0]
 80011d2:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80011d6:	e7e5      	b.n	80011a4 <rcc_osc_off+0x18>
 80011d8:	40023800 	.word	0x40023800
 80011dc:	40023870 	.word	0x40023870
 80011e0:	40023874 	.word	0x40023874

080011e4 <rcc_set_sysclk_source>:
 80011e4:	4a03      	ldr	r2, [pc, #12]	; (80011f4 <rcc_set_sysclk_source+0x10>)
 80011e6:	6813      	ldr	r3, [r2, #0]
 80011e8:	f023 0303 	bic.w	r3, r3, #3
 80011ec:	4318      	orrs	r0, r3
 80011ee:	6010      	str	r0, [r2, #0]
 80011f0:	4770      	bx	lr
 80011f2:	bf00      	nop
 80011f4:	40023808 	.word	0x40023808

080011f8 <rcc_set_ppre2>:
 80011f8:	4a03      	ldr	r2, [pc, #12]	; (8001208 <rcc_set_ppre2+0x10>)
 80011fa:	6813      	ldr	r3, [r2, #0]
 80011fc:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001200:	ea43 3040 	orr.w	r0, r3, r0, lsl #13
 8001204:	6010      	str	r0, [r2, #0]
 8001206:	4770      	bx	lr
 8001208:	40023808 	.word	0x40023808

0800120c <rcc_set_ppre1>:
 800120c:	4a03      	ldr	r2, [pc, #12]	; (800121c <rcc_set_ppre1+0x10>)
 800120e:	6813      	ldr	r3, [r2, #0]
 8001210:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001214:	ea43 2080 	orr.w	r0, r3, r0, lsl #10
 8001218:	6010      	str	r0, [r2, #0]
 800121a:	4770      	bx	lr
 800121c:	40023808 	.word	0x40023808

08001220 <rcc_set_hpre>:
 8001220:	4a03      	ldr	r2, [pc, #12]	; (8001230 <rcc_set_hpre+0x10>)
 8001222:	6813      	ldr	r3, [r2, #0]
 8001224:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001228:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
 800122c:	6010      	str	r0, [r2, #0]
 800122e:	4770      	bx	lr
 8001230:	40023808 	.word	0x40023808

08001234 <rcc_set_main_pll_hse>:
 8001234:	061b      	lsls	r3, r3, #24
 8001236:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 800123a:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 800123e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001242:	4303      	orrs	r3, r0
 8001244:	f647 70c0 	movw	r0, #32704	; 0x7fc0
 8001248:	ea00 1181 	and.w	r1, r0, r1, lsl #6
 800124c:	430b      	orrs	r3, r1
 800124e:	0851      	lsrs	r1, r2, #1
 8001250:	9a00      	ldr	r2, [sp, #0]
 8001252:	3901      	subs	r1, #1
 8001254:	2a02      	cmp	r2, #2
 8001256:	ea4f 4101 	mov.w	r1, r1, lsl #16
 800125a:	bf38      	it	cc
 800125c:	2202      	movcc	r2, #2
 800125e:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 8001262:	0712      	lsls	r2, r2, #28
 8001264:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
 8001268:	430b      	orrs	r3, r1
 800126a:	4313      	orrs	r3, r2
 800126c:	4a01      	ldr	r2, [pc, #4]	; (8001274 <rcc_set_main_pll_hse+0x40>)
 800126e:	6013      	str	r3, [r2, #0]
 8001270:	4770      	bx	lr
 8001272:	bf00      	nop
 8001274:	40023804 	.word	0x40023804

08001278 <rcc_clock_setup_hse_3v3>:
 8001278:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800127a:	4604      	mov	r4, r0
 800127c:	2004      	movs	r0, #4
 800127e:	f7ff ff59 	bl	8001134 <rcc_osc_on>
 8001282:	2004      	movs	r0, #4
 8001284:	f7ff ff4e 	bl	8001124 <rcc_wait_for_osc_ready>
 8001288:	2000      	movs	r0, #0
 800128a:	f7ff ffab 	bl	80011e4 <rcc_set_sysclk_source>
 800128e:	2003      	movs	r0, #3
 8001290:	f7ff ff50 	bl	8001134 <rcc_osc_on>
 8001294:	2003      	movs	r0, #3
 8001296:	f7ff ff45 	bl	8001124 <rcc_wait_for_osc_ready>
 800129a:	7be0      	ldrb	r0, [r4, #15]
 800129c:	2800      	cmp	r0, #0
 800129e:	d135      	bne.n	800130c <rcc_clock_setup_hse_3v3+0x94>
 80012a0:	f000 f946 	bl	8001530 <pwr_set_vos_scale>
 80012a4:	7b20      	ldrb	r0, [r4, #12]
 80012a6:	f7ff ffbb 	bl	8001220 <rcc_set_hpre>
 80012aa:	7b60      	ldrb	r0, [r4, #13]
 80012ac:	f7ff ffae 	bl	800120c <rcc_set_ppre1>
 80012b0:	7ba0      	ldrb	r0, [r4, #14]
 80012b2:	f7ff ffa1 	bl	80011f8 <rcc_set_ppre2>
 80012b6:	79a5      	ldrb	r5, [r4, #6]
 80012b8:	8861      	ldrh	r1, [r4, #2]
 80012ba:	7963      	ldrb	r3, [r4, #5]
 80012bc:	7922      	ldrb	r2, [r4, #4]
 80012be:	7820      	ldrb	r0, [r4, #0]
 80012c0:	9500      	str	r5, [sp, #0]
 80012c2:	f7ff ffb7 	bl	8001234 <rcc_set_main_pll_hse>
 80012c6:	4a12      	ldr	r2, [pc, #72]	; (8001310 <rcc_clock_setup_hse_3v3+0x98>)
 80012c8:	6813      	ldr	r3, [r2, #0]
 80012ca:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80012ce:	6013      	str	r3, [r2, #0]
 80012d0:	2000      	movs	r0, #0
 80012d2:	f7ff ff27 	bl	8001124 <rcc_wait_for_osc_ready>
 80012d6:	68a0      	ldr	r0, [r4, #8]
 80012d8:	f000 f8c4 	bl	8001464 <flash_set_ws>
 80012dc:	2002      	movs	r0, #2
 80012de:	f7ff ff81 	bl	80011e4 <rcc_set_sysclk_source>
 80012e2:	4a0c      	ldr	r2, [pc, #48]	; (8001314 <rcc_clock_setup_hse_3v3+0x9c>)
 80012e4:	6813      	ldr	r3, [r2, #0]
 80012e6:	f3c3 0381 	ubfx	r3, r3, #2, #2
 80012ea:	2b02      	cmp	r3, #2
 80012ec:	d1fa      	bne.n	80012e4 <rcc_clock_setup_hse_3v3+0x6c>
 80012ee:	4b0a      	ldr	r3, [pc, #40]	; (8001318 <rcc_clock_setup_hse_3v3+0xa0>)
 80012f0:	6922      	ldr	r2, [r4, #16]
 80012f2:	601a      	str	r2, [r3, #0]
 80012f4:	4b09      	ldr	r3, [pc, #36]	; (800131c <rcc_clock_setup_hse_3v3+0xa4>)
 80012f6:	6962      	ldr	r2, [r4, #20]
 80012f8:	601a      	str	r2, [r3, #0]
 80012fa:	69a2      	ldr	r2, [r4, #24]
 80012fc:	4b08      	ldr	r3, [pc, #32]	; (8001320 <rcc_clock_setup_hse_3v3+0xa8>)
 80012fe:	2004      	movs	r0, #4
 8001300:	601a      	str	r2, [r3, #0]
 8001302:	b003      	add	sp, #12
 8001304:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8001308:	f7ff bf40 	b.w	800118c <rcc_osc_off>
 800130c:	2001      	movs	r0, #1
 800130e:	e7c7      	b.n	80012a0 <rcc_clock_setup_hse_3v3+0x28>
 8001310:	40023800 	.word	0x40023800
 8001314:	40023808 	.word	0x40023808
 8001318:	20000008 	.word	0x20000008
 800131c:	2000000c 	.word	0x2000000c
 8001320:	20000010 	.word	0x20000010

08001324 <gpio_mode_setup>:
 8001324:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001328:	6805      	ldr	r5, [r0, #0]
 800132a:	68c4      	ldr	r4, [r0, #12]
 800132c:	2600      	movs	r6, #0
 800132e:	f04f 0c03 	mov.w	ip, #3
 8001332:	fa43 f706 	asr.w	r7, r3, r6
 8001336:	07ff      	lsls	r7, r7, #31
 8001338:	d50f      	bpl.n	800135a <gpio_mode_setup+0x36>
 800133a:	0077      	lsls	r7, r6, #1
 800133c:	fa0c fe07 	lsl.w	lr, ip, r7
 8001340:	ea6f 0e0e 	mvn.w	lr, lr
 8001344:	fa01 f807 	lsl.w	r8, r1, r7
 8001348:	ea0e 0505 	and.w	r5, lr, r5
 800134c:	ea0e 0404 	and.w	r4, lr, r4
 8001350:	fa02 f707 	lsl.w	r7, r2, r7
 8001354:	ea48 0505 	orr.w	r5, r8, r5
 8001358:	433c      	orrs	r4, r7
 800135a:	3601      	adds	r6, #1
 800135c:	2e10      	cmp	r6, #16
 800135e:	d1e8      	bne.n	8001332 <gpio_mode_setup+0xe>
 8001360:	6005      	str	r5, [r0, #0]
 8001362:	60c4      	str	r4, [r0, #12]
 8001364:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001368 <gpio_set_af>:
 8001368:	b5f0      	push	{r4, r5, r6, r7, lr}
 800136a:	6a07      	ldr	r7, [r0, #32]
 800136c:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800136e:	2300      	movs	r3, #0
 8001370:	f04f 0e0f 	mov.w	lr, #15
 8001374:	fa42 f403 	asr.w	r4, r2, r3
 8001378:	07e5      	lsls	r5, r4, #31
 800137a:	d507      	bpl.n	800138c <gpio_set_af+0x24>
 800137c:	009d      	lsls	r5, r3, #2
 800137e:	fa0e f405 	lsl.w	r4, lr, r5
 8001382:	ea27 0704 	bic.w	r7, r7, r4
 8001386:	fa01 f505 	lsl.w	r5, r1, r5
 800138a:	432f      	orrs	r7, r5
 800138c:	3301      	adds	r3, #1
 800138e:	2b08      	cmp	r3, #8
 8001390:	d1f0      	bne.n	8001374 <gpio_set_af+0xc>
 8001392:	2300      	movs	r3, #0
 8001394:	f04f 0e0f 	mov.w	lr, #15
 8001398:	f103 0408 	add.w	r4, r3, #8
 800139c:	fa42 f404 	asr.w	r4, r2, r4
 80013a0:	07e4      	lsls	r4, r4, #31
 80013a2:	d507      	bpl.n	80013b4 <gpio_set_af+0x4c>
 80013a4:	009c      	lsls	r4, r3, #2
 80013a6:	fa0e f504 	lsl.w	r5, lr, r4
 80013aa:	ea26 0605 	bic.w	r6, r6, r5
 80013ae:	fa01 f404 	lsl.w	r4, r1, r4
 80013b2:	4326      	orrs	r6, r4
 80013b4:	3301      	adds	r3, #1
 80013b6:	2b08      	cmp	r3, #8
 80013b8:	d1ee      	bne.n	8001398 <gpio_set_af+0x30>
 80013ba:	6207      	str	r7, [r0, #32]
 80013bc:	6246      	str	r6, [r0, #36]	; 0x24
 80013be:	bdf0      	pop	{r4, r5, r6, r7, pc}

080013c0 <usart_set_baudrate>:
 80013c0:	4a08      	ldr	r2, [pc, #32]	; (80013e4 <usart_set_baudrate+0x24>)
 80013c2:	4b09      	ldr	r3, [pc, #36]	; (80013e8 <usart_set_baudrate+0x28>)
 80013c4:	b510      	push	{r4, lr}
 80013c6:	f420 6480 	bic.w	r4, r0, #1024	; 0x400
 80013ca:	4294      	cmp	r4, r2
 80013cc:	681b      	ldr	r3, [r3, #0]
 80013ce:	bf04      	itt	eq
 80013d0:	4b06      	ldreq	r3, [pc, #24]	; (80013ec <usart_set_baudrate+0x2c>)
 80013d2:	681b      	ldreq	r3, [r3, #0]
 80013d4:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 80013d8:	0049      	lsls	r1, r1, #1
 80013da:	fbb3 f3f1 	udiv	r3, r3, r1
 80013de:	6083      	str	r3, [r0, #8]
 80013e0:	bd10      	pop	{r4, pc}
 80013e2:	bf00      	nop
 80013e4:	40011000 	.word	0x40011000
 80013e8:	2000000c 	.word	0x2000000c
 80013ec:	20000010 	.word	0x20000010

080013f0 <usart_set_databits>:
 80013f0:	68c3      	ldr	r3, [r0, #12]
 80013f2:	2908      	cmp	r1, #8
 80013f4:	bf0c      	ite	eq
 80013f6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80013fa:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80013fe:	60c3      	str	r3, [r0, #12]
 8001400:	4770      	bx	lr

08001402 <usart_set_stopbits>:
 8001402:	6903      	ldr	r3, [r0, #16]
 8001404:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8001408:	4319      	orrs	r1, r3
 800140a:	6101      	str	r1, [r0, #16]
 800140c:	4770      	bx	lr

0800140e <usart_set_parity>:
 800140e:	68c3      	ldr	r3, [r0, #12]
 8001410:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8001414:	4319      	orrs	r1, r3
 8001416:	60c1      	str	r1, [r0, #12]
 8001418:	4770      	bx	lr

0800141a <usart_set_mode>:
 800141a:	68c3      	ldr	r3, [r0, #12]
 800141c:	f023 030c 	bic.w	r3, r3, #12
 8001420:	4319      	orrs	r1, r3
 8001422:	60c1      	str	r1, [r0, #12]
 8001424:	4770      	bx	lr

08001426 <usart_set_flow_control>:
 8001426:	6943      	ldr	r3, [r0, #20]
 8001428:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800142c:	4319      	orrs	r1, r3
 800142e:	6141      	str	r1, [r0, #20]
 8001430:	4770      	bx	lr

08001432 <usart_enable>:
 8001432:	68c3      	ldr	r3, [r0, #12]
 8001434:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001438:	60c3      	str	r3, [r0, #12]
 800143a:	4770      	bx	lr

0800143c <usart_send_blocking>:
 800143c:	b538      	push	{r3, r4, r5, lr}
 800143e:	4604      	mov	r4, r0
 8001440:	460d      	mov	r5, r1
 8001442:	f000 f80a 	bl	800145a <usart_wait_send_ready>
 8001446:	4629      	mov	r1, r5
 8001448:	4620      	mov	r0, r4
 800144a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800144e:	f000 b800 	b.w	8001452 <usart_send>

08001452 <usart_send>:
 8001452:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8001456:	6041      	str	r1, [r0, #4]
 8001458:	4770      	bx	lr

0800145a <usart_wait_send_ready>:
 800145a:	6803      	ldr	r3, [r0, #0]
 800145c:	061b      	lsls	r3, r3, #24
 800145e:	d5fc      	bpl.n	800145a <usart_wait_send_ready>
 8001460:	4770      	bx	lr
	...

08001464 <flash_set_ws>:
 8001464:	4a03      	ldr	r2, [pc, #12]	; (8001474 <flash_set_ws+0x10>)
 8001466:	6813      	ldr	r3, [r2, #0]
 8001468:	f023 0307 	bic.w	r3, r3, #7
 800146c:	4318      	orrs	r0, r3
 800146e:	6010      	str	r0, [r2, #0]
 8001470:	4770      	bx	lr
 8001472:	bf00      	nop
 8001474:	40023c00 	.word	0x40023c00

08001478 <rcc_periph_clock_enable>:
 8001478:	0943      	lsrs	r3, r0, #5
 800147a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800147e:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 8001482:	f000 021f 	and.w	r2, r0, #31
 8001486:	6819      	ldr	r1, [r3, #0]
 8001488:	2001      	movs	r0, #1
 800148a:	4090      	lsls	r0, r2
 800148c:	4308      	orrs	r0, r1
 800148e:	6018      	str	r0, [r3, #0]
 8001490:	4770      	bx	lr

08001492 <blocking_handler>:
 8001492:	e7fe      	b.n	8001492 <blocking_handler>

08001494 <null_handler>:
 8001494:	4770      	bx	lr
	...

08001498 <reset_handler>:
 8001498:	4c1a      	ldr	r4, [pc, #104]	; (8001504 <reset_handler+0x6c>)
 800149a:	491b      	ldr	r1, [pc, #108]	; (8001508 <reset_handler+0x70>)
 800149c:	481b      	ldr	r0, [pc, #108]	; (800150c <reset_handler+0x74>)
 800149e:	2200      	movs	r2, #0
 80014a0:	1853      	adds	r3, r2, r1
 80014a2:	4283      	cmp	r3, r0
 80014a4:	d31a      	bcc.n	80014dc <reset_handler+0x44>
 80014a6:	4a1a      	ldr	r2, [pc, #104]	; (8001510 <reset_handler+0x78>)
 80014a8:	2100      	movs	r1, #0
 80014aa:	4293      	cmp	r3, r2
 80014ac:	d31a      	bcc.n	80014e4 <reset_handler+0x4c>
 80014ae:	4a19      	ldr	r2, [pc, #100]	; (8001514 <reset_handler+0x7c>)
 80014b0:	4c19      	ldr	r4, [pc, #100]	; (8001518 <reset_handler+0x80>)
 80014b2:	6813      	ldr	r3, [r2, #0]
 80014b4:	4d19      	ldr	r5, [pc, #100]	; (800151c <reset_handler+0x84>)
 80014b6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80014ba:	6013      	str	r3, [r2, #0]
 80014bc:	6f53      	ldr	r3, [r2, #116]	; 0x74
 80014be:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80014c2:	6753      	str	r3, [r2, #116]	; 0x74
 80014c4:	42ac      	cmp	r4, r5
 80014c6:	d310      	bcc.n	80014ea <reset_handler+0x52>
 80014c8:	4c15      	ldr	r4, [pc, #84]	; (8001520 <reset_handler+0x88>)
 80014ca:	4d16      	ldr	r5, [pc, #88]	; (8001524 <reset_handler+0x8c>)
 80014cc:	42ac      	cmp	r4, r5
 80014ce:	d310      	bcc.n	80014f2 <reset_handler+0x5a>
 80014d0:	f7fe feb4 	bl	800023c <main>
 80014d4:	4c14      	ldr	r4, [pc, #80]	; (8001528 <reset_handler+0x90>)
 80014d6:	4d15      	ldr	r5, [pc, #84]	; (800152c <reset_handler+0x94>)
 80014d8:	42ac      	cmp	r4, r5
 80014da:	d30e      	bcc.n	80014fa <reset_handler+0x62>
 80014dc:	5913      	ldr	r3, [r2, r4]
 80014de:	5053      	str	r3, [r2, r1]
 80014e0:	3204      	adds	r2, #4
 80014e2:	e7dd      	b.n	80014a0 <reset_handler+0x8>
 80014e4:	6019      	str	r1, [r3, #0]
 80014e6:	3304      	adds	r3, #4
 80014e8:	e7df      	b.n	80014aa <reset_handler+0x12>
 80014ea:	f854 3b04 	ldr.w	r3, [r4], #4
 80014ee:	4798      	blx	r3
 80014f0:	e7e8      	b.n	80014c4 <reset_handler+0x2c>
 80014f2:	f854 3b04 	ldr.w	r3, [r4], #4
 80014f6:	4798      	blx	r3
 80014f8:	e7e8      	b.n	80014cc <reset_handler+0x34>
 80014fa:	f854 3b04 	ldr.w	r3, [r4], #4
 80014fe:	4798      	blx	r3
 8001500:	e7ea      	b.n	80014d8 <reset_handler+0x40>
 8001502:	bf00      	nop
 8001504:	08001760 	.word	0x08001760
 8001508:	20000000 	.word	0x20000000
 800150c:	20000014 	.word	0x20000014
 8001510:	20001518 	.word	0x20001518
 8001514:	e000ed14 	.word	0xe000ed14
 8001518:	08001760 	.word	0x08001760
 800151c:	08001760 	.word	0x08001760
 8001520:	08001760 	.word	0x08001760
 8001524:	08001760 	.word	0x08001760
 8001528:	08001760 	.word	0x08001760
 800152c:	08001760 	.word	0x08001760

08001530 <pwr_set_vos_scale>:
 8001530:	b928      	cbnz	r0, 800153e <pwr_set_vos_scale+0xe>
 8001532:	4a06      	ldr	r2, [pc, #24]	; (800154c <pwr_set_vos_scale+0x1c>)
 8001534:	6813      	ldr	r3, [r2, #0]
 8001536:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800153a:	6013      	str	r3, [r2, #0]
 800153c:	4770      	bx	lr
 800153e:	2801      	cmp	r0, #1
 8001540:	d1fc      	bne.n	800153c <pwr_set_vos_scale+0xc>
 8001542:	4a02      	ldr	r2, [pc, #8]	; (800154c <pwr_set_vos_scale+0x1c>)
 8001544:	6813      	ldr	r3, [r2, #0]
 8001546:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800154a:	e7f6      	b.n	800153a <pwr_set_vos_scale+0xa>
 800154c:	40007000 	.word	0x40007000

08001550 <memcpy>:
 8001550:	4684      	mov	ip, r0
 8001552:	ea41 0300 	orr.w	r3, r1, r0
 8001556:	f013 0303 	ands.w	r3, r3, #3
 800155a:	d16d      	bne.n	8001638 <memcpy+0xe8>
 800155c:	3a40      	subs	r2, #64	; 0x40
 800155e:	d341      	bcc.n	80015e4 <memcpy+0x94>
 8001560:	f851 3b04 	ldr.w	r3, [r1], #4
 8001564:	f840 3b04 	str.w	r3, [r0], #4
 8001568:	f851 3b04 	ldr.w	r3, [r1], #4
 800156c:	f840 3b04 	str.w	r3, [r0], #4
 8001570:	f851 3b04 	ldr.w	r3, [r1], #4
 8001574:	f840 3b04 	str.w	r3, [r0], #4
 8001578:	f851 3b04 	ldr.w	r3, [r1], #4
 800157c:	f840 3b04 	str.w	r3, [r0], #4
 8001580:	f851 3b04 	ldr.w	r3, [r1], #4
 8001584:	f840 3b04 	str.w	r3, [r0], #4
 8001588:	f851 3b04 	ldr.w	r3, [r1], #4
 800158c:	f840 3b04 	str.w	r3, [r0], #4
 8001590:	f851 3b04 	ldr.w	r3, [r1], #4
 8001594:	f840 3b04 	str.w	r3, [r0], #4
 8001598:	f851 3b04 	ldr.w	r3, [r1], #4
 800159c:	f840 3b04 	str.w	r3, [r0], #4
 80015a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80015a4:	f840 3b04 	str.w	r3, [r0], #4
 80015a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80015ac:	f840 3b04 	str.w	r3, [r0], #4
 80015b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80015b4:	f840 3b04 	str.w	r3, [r0], #4
 80015b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80015bc:	f840 3b04 	str.w	r3, [r0], #4
 80015c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80015c4:	f840 3b04 	str.w	r3, [r0], #4
 80015c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80015cc:	f840 3b04 	str.w	r3, [r0], #4
 80015d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80015d4:	f840 3b04 	str.w	r3, [r0], #4
 80015d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80015dc:	f840 3b04 	str.w	r3, [r0], #4
 80015e0:	3a40      	subs	r2, #64	; 0x40
 80015e2:	d2bd      	bcs.n	8001560 <memcpy+0x10>
 80015e4:	3230      	adds	r2, #48	; 0x30
 80015e6:	d311      	bcc.n	800160c <memcpy+0xbc>
 80015e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80015ec:	f840 3b04 	str.w	r3, [r0], #4
 80015f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80015f4:	f840 3b04 	str.w	r3, [r0], #4
 80015f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80015fc:	f840 3b04 	str.w	r3, [r0], #4
 8001600:	f851 3b04 	ldr.w	r3, [r1], #4
 8001604:	f840 3b04 	str.w	r3, [r0], #4
 8001608:	3a10      	subs	r2, #16
 800160a:	d2ed      	bcs.n	80015e8 <memcpy+0x98>
 800160c:	320c      	adds	r2, #12
 800160e:	d305      	bcc.n	800161c <memcpy+0xcc>
 8001610:	f851 3b04 	ldr.w	r3, [r1], #4
 8001614:	f840 3b04 	str.w	r3, [r0], #4
 8001618:	3a04      	subs	r2, #4
 800161a:	d2f9      	bcs.n	8001610 <memcpy+0xc0>
 800161c:	3204      	adds	r2, #4
 800161e:	d008      	beq.n	8001632 <memcpy+0xe2>
 8001620:	07d2      	lsls	r2, r2, #31
 8001622:	bf1c      	itt	ne
 8001624:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001628:	f800 3b01 	strbne.w	r3, [r0], #1
 800162c:	d301      	bcc.n	8001632 <memcpy+0xe2>
 800162e:	880b      	ldrh	r3, [r1, #0]
 8001630:	8003      	strh	r3, [r0, #0]
 8001632:	4660      	mov	r0, ip
 8001634:	4770      	bx	lr
 8001636:	bf00      	nop
 8001638:	2a08      	cmp	r2, #8
 800163a:	d313      	bcc.n	8001664 <memcpy+0x114>
 800163c:	078b      	lsls	r3, r1, #30
 800163e:	d08d      	beq.n	800155c <memcpy+0xc>
 8001640:	f010 0303 	ands.w	r3, r0, #3
 8001644:	d08a      	beq.n	800155c <memcpy+0xc>
 8001646:	f1c3 0304 	rsb	r3, r3, #4
 800164a:	1ad2      	subs	r2, r2, r3
 800164c:	07db      	lsls	r3, r3, #31
 800164e:	bf1c      	itt	ne
 8001650:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001654:	f800 3b01 	strbne.w	r3, [r0], #1
 8001658:	d380      	bcc.n	800155c <memcpy+0xc>
 800165a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800165e:	f820 3b02 	strh.w	r3, [r0], #2
 8001662:	e77b      	b.n	800155c <memcpy+0xc>
 8001664:	3a04      	subs	r2, #4
 8001666:	d3d9      	bcc.n	800161c <memcpy+0xcc>
 8001668:	3a01      	subs	r2, #1
 800166a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800166e:	f800 3b01 	strb.w	r3, [r0], #1
 8001672:	d2f9      	bcs.n	8001668 <memcpy+0x118>
 8001674:	780b      	ldrb	r3, [r1, #0]
 8001676:	7003      	strb	r3, [r0, #0]
 8001678:	784b      	ldrb	r3, [r1, #1]
 800167a:	7043      	strb	r3, [r0, #1]
 800167c:	788b      	ldrb	r3, [r1, #2]
 800167e:	7083      	strb	r3, [r0, #2]
 8001680:	4660      	mov	r0, ip
 8001682:	4770      	bx	lr
 8001684:	74003174 	.word	0x74003174
 8001688:	0032      	.short	0x0032
 800168a:	6146      	.short	0x6146
 800168c:	64656c69 	.word	0x64656c69
 8001690:	206f7420 	.word	0x206f7420
 8001694:	65636572 	.word	0x65636572
 8001698:	20657669 	.word	0x20657669
 800169c:	6d657469 	.word	0x6d657469
 80016a0:	74697720 	.word	0x74697720
 80016a4:	206e6968 	.word	0x206e6968
 80016a8:	30303031 	.word	0x30303031
 80016ac:	00736d20 	.word	0x00736d20
 80016b0:	65636552 	.word	0x65636552
 80016b4:	64657669 	.word	0x64657669
 80016b8:	0d00203a 	.word	0x0d00203a
 80016bc:	000a      	.short	0x000a
 80016be:	6146      	.short	0x6146
 80016c0:	64656c69 	.word	0x64656c69
 80016c4:	206f7420 	.word	0x206f7420
 80016c8:	646e6573 	.word	0x646e6573
 80016cc:	65746920 	.word	0x65746920
 80016d0:	6f74206d 	.word	0x6f74206d
 80016d4:	65757120 	.word	0x65757120
 80016d8:	77206575 	.word	0x77206575
 80016dc:	69687469 	.word	0x69687469
 80016e0:	3035206e 	.word	0x3035206e
 80016e4:	00736d30 	.word	0x00736d30
 80016e8:	454c4449 	.word	0x454c4449
 80016ec:	00000000 	.word	0x00000000

080016f0 <rcc_hse_8mhz_3v3>:
 80016f0:	00600008 00000202 00000603 01040500     ..`.............
 8001700:	02dc6c00 00b71b00 016e3600 01500008     .l.......6n...P.
 8001710:	00000704 00000602 00000400 0501bd00     ................
 8001720:	0280de80 0501bd00 00f00008 00000502     ................
 8001730:	00000603 01040500 07270e00 01c9c380     ..........'.....
 8001740:	03938700 01500008 00000702 00000605     ......P.........
 8001750:	00040500 0a037a00 0280de80 0501bd00     .....z..........
